---
slug: react2
title: useMemo and useCallback, you really know it?
authors: [sheldon]
tags: [react]
---

import { useState, useMemo, useCallback } from "react";

:::tip
- è¿™ç¯‡blogæ˜¯å¯¹useMemo å’Œ useCallbackçš„æ·±å…¥å­¦ä¹ ã€‚ 
:::

useMemo å’Œ useCallback æ˜¯react æä¾›çš„æ€§èƒ½ä¼˜åŒ–å·¥å…·ã€‚ç”¨æ³•æ¯”è¾ƒç®€å•ï¼Œæˆ‘ä»¬åœ¨é¡¹ç›®ä¸­ä¹ŸçŸ¥é“è¦ç”¨ï¼Œä½†æ˜¯å…·ä½“æ€§èƒ½æ˜¯å¦‚ä½•æå‡çš„ï¼Œæ˜¯ä¸æ˜¯å¯ä»¥å¯è§†åŒ–å‡ºæ¥ï¼Œ
ç›¸ä¿¡æœ‰å¾ˆå¤šäººå¹¶ä¸æ˜¯ç‰¹åˆ«äº†è§£ã€‚è¿™ç¯‡blogç”±æ­¤è€Œç”Ÿã€‚

<!--truncate-->

## 1. useMemo

** Returns a memoized value. **

è¿”å›ä¸€ä¸ª[ç¼“å­˜å€¼](https://reactjs.org/docs/hooks-reference.html#usememo), è¿™ä¸ªæ˜¯å®˜ç½‘å¯¹useMemoæè¿°çš„ç¬¬ä¸€å¥è¯ã€‚å¦‚ä½•ç†è§£è¿™ä¸ªç¼“å­˜å€¼å°±å¾ˆå…³é”®ï¼Œ
å®é™…ä¸Šå®˜ç½‘ä¹Ÿæä¾›äº†å¯¹åº”çš„ç»´åŸºç™¾ç§‘çš„linkã€‚æˆ‘æŠŠå…³é”®çš„é¢è¯•copyåˆ°ä¸‹é¢ï¼š

:::note
In computing, memoization or memoisation is an optimization technique used primarily to speed up computer programs by storing
the results of expensive funtion calls and returning the cached result when the same inputs occur again.
:::

æ‰€ä»¥æˆ‘è€ƒè™‘å†ä¸‰ï¼Œç¼“å­˜å€¼è¿˜æ˜¯æ¯”è¾ƒåˆé€‚çš„ï¼Œä»–çš„ç‰¹ç‚¹å°±æ˜¯å¦‚æœå†æœ‰ç›¸åŒè¾“å…¥ï¼Œé‚£ä¹ˆå°±æ— éœ€è®¡ç®—ï¼Œç›´æ¥è¿”å›ç¼“å­˜å€¼å³å¯ï¼Œä»æœªæå‡ç”Ÿä»£ç æ€§èƒ½ã€‚

æˆ‘ä»¬å†å›åˆ°useMemoï¼ŒPass a â€œcreateâ€ function and an array of dependencies. 
useMemo will only recompute the memoized value when one of the dependencies has changed. 
This optimization helps to avoid expensive calculations on every render.

å®ƒçš„å‚æ•°æ˜¯ä¸€ä¸ªfunction(ä¸æ˜¯å›è°ƒ)å’Œä¸€ä¸ªä¾èµ–æ•°ç»„ã€‚æ•°ç»„ä¸­çš„ä¾èµ–å‘ç”Ÿå˜åŒ–æ‰ä¼šè§¦å‘å‡½æ•°ä¸­çš„è®¡ç®—ã€‚
å¦‚æœå®˜ç½‘çš„æè¿°ä¸æ˜¯å¾ˆæ¸…æ™°ï¼Œä¸‹é¢æ˜¯æˆ‘ä»å…¶ä»–blogæ‰¾åˆ°çš„ä¸€æ®µæ›´ä¸ºæ¸…æ™°çš„ä¸€æ®µuseMemoæè¿°ã€‚

:::note
React has a built-in hook called useMemo that allows you to memoize expensive functions 
so that you can avoid calling them on every render. You simple pass in a function and an array of inputs 
and useMemo will only recompute the memoized value when one of the inputs has changed.
:::

ä½¿ç”¨useMemoéœ€è¦æ³¨æ„çš„å‡ ç‚¹ï¼š

:::tip
1. **Donâ€™t do anything there that you wouldnâ€™t normally do while rendering.** For example, side effects belong in useEffect, not useMemo.

2. If no array is provided, **a new value will be computed on every render**.

3. You may rely on useMemo as a performance optimization, **not as a semantic guarantee**. In the future, React may choose to â€œforgetâ€ some previously memoized values and recalculate them on next render, e.g. to free memory for offscreen components. **Write your code so that it still works without useMemo** â€” and then add it to optimize performance.
:::

ä¸‹é¢èƒ½æˆ‘ä»¬å°±show case for useMemoï¼Œå¯è§†åŒ–çš„è®©å¤§å®¶å¯ä»¥ä½“éªŒä¸€ä¸‹ä»–çš„æ€§èƒ½æå‡ã€‚

æµ‹è¯•æ–¹æ³•ï¼š

1. ç‚¹å‡»Next wordï¼Œå¯ä»¥æ„Ÿå—åˆ°ç”±äºå¤æ‚è®¡ç®—å¸¦æ¥çš„å»¶è¿Ÿï¼Œç‚¹å‡»Incrementï¼Œ ç”±äºå¤æ‚è®¡ç®—è¢«useMemoä¼˜åŒ–ï¼Œæ‰€ä»¥æ„Ÿå—ä¸åˆ°å»¶è¿Ÿå½±å“ã€‚
è¿ç»­ç‚¹å‡»æ•ˆæœæ›´æ˜æ˜¾ã€‚

2. æ³¨é‡Šæ‰ä¸‹é¢useMemoä»£ç ï¼Œæš´éœ²å¤æ‚è®¡ç®—åœ¨renderè¿‡ç¨‹ä¸­ã€‚é‡å¤ä¸Šé¢çš„åŠ¨ä½œï¼Œç‚¹å‡»Incrementçš„æ—¶å€™ä¹Ÿå‡ºç°å»¶è¿Ÿæ•ˆæœï¼Œå®é™…ä¸Šæ˜¯ä¸éœ€è¦çš„ã€‚


```jsx live

function TestUseMemo() {

  // State for our counter
  const [count, setCount] = useState(0);
  
  // State to keep track of current word in array we want to show
  const [wordIndex, setWordIndex] = useState(0);
  
  // Words we can flip through and view letter count
  const words = ["hey", "this", "is", "cool"];
  const word = words[wordIndex];
  
  // Returns number of letters in a word
  // We make it slow by including a large and completely unnecessary loop
  const computeLetterCount = (word) => {
    let i = 0;
    while (i < 1000000000) i++;
    return word.length;
  };
  
  // Memoize computeLetterCount so it uses cached return value if input array ...
  // ... values are the same as last time the function was run.
  // é’ˆå¯¹æ€§çš„åœ¨éœ€è¦çš„ä¾èµ–ä¸‹è¿›è¡Œè®¡ç®—ï¼Œå…¶ä»–çš„ä¾èµ–æ”¹å˜çš„æ—¶å€™ç”¨cacheæ•°æ®ï¼Œä»è€Œæå‡æ•´ä½“æ€§èƒ½
  const letterCount = useMemo(() => computeLetterCount(word), [word]);
  
  // This would result in lag when incrementing the counter because ...
  // ... we'd have to wait for expensive function when re-rendering.
  //const letterCount = computeLetterCount(word);
  
  return (
    <div style={{ padding: "15px" }}>
      <h2>Compute number of letters (slow ğŸŒ)</h2>
      <p>
        "{word}" has {letterCount} letters
      </p>
      <button
        onClick={() => {
          const next = wordIndex + 1 === words.length ? 0 : wordIndex + 1;
          setWordIndex(next);
        }}
      >
        Next word
      </button>
      <h2>Increment a counter (fast âš¡ï¸)</h2>
      <p>Counter: {count}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
}

```

**æ‰€ä»¥ç»“è®ºå°±æ˜¯åœ¨renderä¸­çš„å¤æ‚è®¡ç®—ï¼Œéœ€è¦useMemoæ¥è¿›è¡Œç›¸å…³ä¾èµ–ä¸‹çš„æ€§èƒ½ä¼˜åŒ–ã€‚**

## 1. useCallback

** Returns a memoized callback.. **

è¿”å›ä¸€ä¸ª[ç¼“å­˜å›è°ƒ](https://reactjs.org/docs/hooks-reference.html#usecallback), æˆ‘ä»¬å¯ä»¥å¯¹æ¯”ä¸Šé¢çš„useMemoæ¥çœ‹ï¼Œè¿™æ¬¡ç¼“å­˜çš„å®é™…ä¸Šæ˜¯æˆ‘ä»¬çš„å‡½æ•°æ–¹æ³•æœ¬èº«ã€‚

æ¥çœ‹å®˜ç½‘çš„è§£é‡Šï¼ŒPass an inline callback and an array of dependencies. 
useCallback will return a memoized version of the callback that only changes if one of the dependencies has changed. 
This is useful when passing callbacks to optimized child components that rely on reference equality 
to prevent unnecessary renders (e.g. shouldComponentUpdate).

å’ŒuseMemoçš„æè¿°å¯¹æ¯”ï¼Œè¿™é‡Œé¢å¾ˆæ˜æ˜¾å‘Šè¯‰äº†æˆ‘ä»¬ä»€ä¹ˆæ—¶å€™ç”¨useCallbackæ¯”è¾ƒåˆé€‚ï¼Œå°±æ˜¯shouldComponentUpdateä¹‹å‰ä»€ä¹ˆæ—¶å€™ç”¨ï¼Œç°åœ¨ä½ å°±å¯ä»¥è€ƒè™‘ç”¨useCallbackã€‚
ä¸‹é¢æ˜¯shouldComponentUpdateçš„å®˜ç½‘æè¿°ã€‚

:::note
Use shouldComponentUpdate() to let React know if a componentâ€™s output is not affected by the current change in state or props. 
The default behavior is to re-render on every state change
:::

æ‰€ä»¥ä»–æ˜¯ç”¨æ¥ä¼˜åŒ–é™åˆ¶å­ç»„ä»¶æ¸²æŸ“æ¬¡æ•°çš„ã€‚å¦‚æœå®˜ç½‘çš„æè¿°ä¸æ˜¯å¾ˆæ¸…æ™°ï¼Œä¸‹é¢æ˜¯æˆ‘ä»å…¶ä»–blogæ‰¾åˆ°çš„ä¸€æ®µæ›´ä¸ºæ¸…æ™°çš„ä¸€æ®µuseCallbackæè¿°ã€‚

:::note
The useCallback hook is used when you have a component in which the child is rerendering again and again without need.
Pass an inline callback and an array of dependencies. useCallback will return a memoized version of the callback that only changes 
if one of the dependencies has changed.
:::

ä½¿ç”¨useMemoéœ€è¦æ³¨æ„çš„å‡ ç‚¹ï¼š

:::tip
1. useCallback(fn, deps) is equivalent to useMemo(() => fn, deps)

2. useMemoå’ŒuseCallBack, åœ¨æœªæ¥çš„reactç‰ˆæœ¬ä¸­ï¼Œç¬¬äºŒä¸ªå‚æ•°ï¼Œä¾èµ–æ•°ç»„æ˜¯ä¼šè¢«å»æ‰çš„

:::

ä¸‹é¢èƒ½æˆ‘ä»¬å°±show case for useCallbackï¼Œå¯è§†åŒ–çš„è®©å¤§å®¶å¯ä»¥ä½“éªŒä¸€ä¸‹ä»–çš„æ€§èƒ½æå‡ã€‚

æµ‹è¯•æ–¹æ³•ï¼š

1. ä»£ç ä¸­çš„funccountå®šä¹‰ä¸º
```jsx
let funccount = new Set();

// Set å¯¹è±¡æ˜¯å”¯ä¸€å€¼çš„é›†åˆï¼Œæ¯ä¸ªå€¼åœ¨ Set ä¸­åªèƒ½å‡ºç°ä¸€æ¬¡ã€‚
// å¦‚æœå¯¹Set()å®šä¹‰ä¸æ˜¯å’Œæ¸…æ¥šï¼Œå¯ä»¥å‚è€ƒå¦‚ä¸‹æµ‹è¯•ç†è§£ï¼š
const set1 = new Set();

set1.add(1) 
set1.add(2)  
set1.add(3) 
set1.add(1) 

set1.size // 3
```

2. éœ€è¦F12ï¼Œçœ‹console logçš„è°ƒç”¨æ¬¡æ•°

3. ç‚¹å‡»å¦‚ä¸‹ä¸‰ä¸ªæŒ‰é’®ï¼Œåœ¨æ²¡æœ‰ä½¿ç”¨useCallBackçš„æ—¶å€™éƒ½æ˜¯æ¸²æŸ“3æ¬¡ç´¯åŠ ï¼Œè¯´æ˜æ¯æ¬¡render3ä¸ªæ–¹æ³•éƒ½ä¼šè¢«é‡æ–°æ¸²æŸ“åˆ°ã€‚

4. æ³¨é‡Šæ‰åŸæœ‰æ–¹æ³•ï¼Œæ‰“å¼€useCallbackçš„æ–¹æ³•ï¼Œå†æ¬¡è§‚å¯Ÿæ¸²æŸ“æ¬¡æ•°ï¼Œä¼šå‘ç°å’Œä¾èµ–äº§ç”Ÿå…³ç³»ï¼Œæ²¡æœ‰è§¦å‘çš„å­ç»„ä»¶ä¹Ÿä¸ä¼šè¢«æ¸²æŸ“äº†ã€‚


```jsx live
function TestUseCallback() {

  const [count, setCount] = useState(0)
  const [number, setNumber] = useState(0)
 
  const incrementCounter = () => {
    setCount(count + 1)
  }
  const decrementCounter = () => {
    setCount(count - 1)
  }
   
   const incrementNumber = () => {
    setNumber(number + 1)
  }

  /*
  const incrementCounter = useCallback(() => {
    setCount(count + 1)
  }, [count])

  const decrementCounter = useCallback(() => {
    setCount(count - 1)
  }, [count])

  const incrementNumber = useCallback(() => {
    setNumber(number + 1)
  }, [number])
  */ 

  funccount.add(incrementCounter);
  funccount.add(decrementCounter);
  funccount.add(incrementNumber);
  console.log('funccount.size:' + funccount.size);
 
  return (
    <div>
      <h2>Count: {count}</h2>
      <h2>Number: {number}</h2>
      <button onClick={incrementCounter}>
         Increase counter
      </button>
      <button onClick={decrementCounter}>
         Decrease Counter
      </button>
      <button onClick={incrementNumber}>
         increase number
      </button>
    </div>
  )
}
 

```

æ€»ç»“å°±æ˜¯useCallbacké’ˆå¯¹å‡½æ•°ç¼“å­˜ï¼Œä¸»è¦é™åˆ¶å­ç»„ä»¶çš„æ¸²æŸ“æ¬¡æ•°

åé¢æˆ‘è¿˜ä¼šå¯¹Memoè¿›è¡Œä¸€ä¸ªæ€»ç»“çš„ã€‚
