<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title>MetaTrip Blog</title>
        <link> https://777sunny777.github.io/metaTrip/metaTrip/build/blog</link>
        <description>MetaTrip Blog</description>
        <lastBuildDate>Tue, 03 Jan 2023 00:00:00 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>https://github.com/jpmonette/feed</generator>
        <item>
            <title><![CDATA[react ui library 技术总结]]></title>
            <link> https://777sunny777.github.io/metaTrip/metaTrip/build/blog/ui1</link>
            <guid>ui1</guid>
            <pubDate>Tue, 03 Jan 2023 00:00:00 GMT</pubDate>
            <description><![CDATA[- 这篇blog是对所做的一套react ui library技术总结]]></description>
            <content:encoded><![CDATA[<p>:::tip</p><ul><li>这篇blog是对所做的一套react ui library技术总结
:::</li></ul><h2>1. 当前现状</h2><p>我从2018年5月到A公司，至今超过4年半，将近5年的时间，其中从19年中旬开始做react ui library，到目前差不多也有3年半左右的经验。
这期间经历了两套组件库，第二套基于react 16 hooks开发，至今也有三年左右的时间。这次主要讲的也就是第二套。</p><p>react组件库其实有很多，比较有名的，google的MUI，推特的bootstrap等等，A公司比较大，制作自己的组件库的原因主要是要符合自身的标准，
被公司内部的项目使用，这个标准主要有design，和accessibility两种。还有就是一些功能上的例子，直接用三方的往往需要改造，
并且如果接口不完善，也改造不好，自己做一套才显得更有魄力。</p><p>这个项目实际上是没有自有资金的，所以发展的比较缓慢，目前为止直接45个react常用组件，并且支持5种charts类型，体量上趋近于MUI，
目前服务于14个业务线，这个也是我们比较好的战绩体现。使用组件库可以大幅的减少项目ui的开发时间，这个大家都有认识，这个效率大概是90%。</p><h2>2. 框架设计</h2><p>抱歉我还不能图文并茂的展示内部项目，这里我只能文字性的描述：</p><p>1.项目的表现层主要用的到技术是： </p><p>react(16/17 hooks之后)，styled-components, styled system(这两块主要用来写css in js)，
style dictionary用来管理theme token(它主要是可以将json格式转化成很多文件格式，用以引用)，storybook用来展示case demo，
docusaurus用来写website 文档，typescript辅助管理接口，react testing library+jest+jest-styled-components 来做UT，
robot framework+Selenium Library来做auto testing，D3 V7来做charts</p><p>2.中间层主要用到的技术是：</p><p>node js环境，yarn+lerna来管理monoRepo</p><p>3.代码层主要用到的技术是：</p><p>GitHub 存放管理代码，nexus来存放发布ui包</p><p><strong> 下面有会重点总结如下几个关键技术：</strong></p><h3>2-1. Muti-repo and Monorepo</h3><p>:::note
前面说过我做过两套react组件库，第一套使用的是Muti-repo, 第二套使用的是Monorepo
这两种repo的开发管理模式或者优缺点是什么呢？我根据实际经验和大家聊一下。
:::</p><p>首先提前需要说到的两点是：</p><p>1.这两种模式没有优劣，需要根据项目特点，开发需求来定
2.某种模式下的缺点也是可以尽量弥补的，不是完全解决不了的，不过你需要额外的efforts</p><h4>2-1-1. repo management</h4><p>对于组件库而言，日常的库管理包括：branch管理，github issue，release changelog，
readme文件，monorepo相比muti 很容易理解会更加的合适和方便，history search这块应该就见仁见智了</p><h4>2-1-2. quality control</h4><p>质量把控方面，cicd/pipeline，这个设置上mono更方便; storybook cases设置上也更容易是一个整体。
muti-repo一般情况下是分开的，一个repo或者一个组件是单独的storybook cases，
当然你也可以设置一个大壳子，来整体展示组件，但是就需要额外的开发成本。</p><p>这块你可能会问，问什么要把storybook cases 放到一块去好一些？ 组件库是一个整体，不是相互独立的多个组件的集合。
组件内部的联系远比你想象的多，放在一起可以整体把握impacts，无论是manual check， UT还是auto testing，还是site部署都容易的多。</p><p>PR review 也是见仁见智，mono review的成本更大，一个PR 包含信息更多
muti review PR想多简单一些，但是组件间关联的潜在问题可能无法及时暴漏
还有公共方法的修改要小心，UT也无法第一时间覆盖到。</p><h4>2-1-3. release control</h4><p>muti release更加灵活， package的引用也更加灵活
mono ui包的组件是同时来release的，影响范围大， release风险相对较高，失败的可能性大</p><h4>2-1-4. version control</h4><p>muti 组件间版本依赖问题，嵌套问题，同步问题需要很好的策略来解决，
npm install需要花费更多时间 </p><h3>2-2. npm and yarn</h3><p>:::note
第二套使用的yarn来安装管理packages</p><p>参考：<a href="https://www.knowledgehut.com/blog/web-development/yarn-vs-npm">https://www.knowledgehut.com/blog/web-development/yarn-vs-npm</a>
:::</p><p>首先nodejs是前端开发都会使用的到工具，他是基于V8引擎开发的js runtime ENV。</p><p><strong> NPM：node package manager </strong>，node包管理工具（install，update，manage， remove）这几项。
他是node的默认工具，安装node的时候就会预安装npm</p><p><strong> Yarn: Yet Another Resource Navigator</strong>, 最早是16年由Facebook开发的另一套nodejs 包管理工具。因为他不是预安装的，所以需要通过npm先进行安装</p><pre><code class="language-jsx">npm install yarn -g
</code></pre><p>简单来说yarn促进了npm的发展，比如说yarn是第一个带来版本锁定功能的工具，后面npm也实现了这个功能，
目前来看两者相比较，yarn的安装速度也更快一些。</p><p>先说一些共同点，两者都可以生成lock文件；都支持offline的时候install from cache；都支持workspaces。monorepo的开发模式（npm v7）
<a href="https://docs.npmjs.com/cli/v7/using-npm/workspaces">https://docs.npmjs.com/cli/v7/using-npm/workspaces</a>
都提供了npx，dlx来执行依赖命令，这个可以是还没有安装的依赖。</p><p><strong> NPX：Node package Execute</strong>， （npm v5.2, 有了直接执行，没有会先下载）</p><p>然后再说下为啥yarn会比npm快一些：主要有两点，第一个是parallel installation.
<a href="https://blog.csdn.net/yuqing1008/article/details/107328920/">https://blog.csdn.net/yuqing1008/article/details/107328920/</a>
这个设计到yarn install包的有限队列规则与npm不同，有兴趣大家可以去看文档</p><p>第二个就是plug&#x27;n&#x27;play feature，即插即用功能，yarn v2 才有的
简单来说，一般npm 会先解析版本，下载到缓存区，解压，再拷贝到项目的node_modules 路径中去，
如果同一个包版本不同，会嵌套进去再拷贝。</p><p>查找的时候是逆着来的，子集里面没有再到root里面的node_modules里查找，这样就有大量的I/O操作</p><p>yarn的这个功能，并不会直接把依赖考到项目的node_modules 路径中去，而是在pnp.js 文件中记录下来缓存中具体位置
这样就避免了大量的I/O操作，同时也不会有node_modules目录生成</p><h3>2-3. lerna management</h3><p>:::note
lerna是一个管理js monorepo的工具
:::</p><p>简单说几个常用命令：</p><pre><code class="language-jsx">1.lerna init

//1.安装lerna到devdenpendency
//2.生成一个lerna.json的config 文件

这里面注意 &quot;version&quot;: &quot;independent&quot; 可以各个包发布不同版本

//3. 生成gitignore 如果没有的话
</code></pre><pre><code class="language-jsx">2. lerna bootstrap

//1. npm install
//2. Symlink
</code></pre><pre><code class="language-jsx">3. lerna changed
查看package的变化名单
</code></pre><pre><code class="language-jsx">4. lerna version --no-private
https://github.com/lerna/lerna/tree/main/commands/version#readme
发布之前更新版本的，可以选择，并且把依赖中的版本也都一起更新了

</code></pre><pre><code class="language-jsx">5. lerna publish --no-private
https://github.com/lerna/lerna/tree/main/commands/publish#readme
发布package，包含更新版本选择
</code></pre><h3>2-4. styled components and styled system</h3><p>:::note
styled components css in js的框架</p><p>styled system 是快速构建UI的一个辅助工具
:::</p><p>这里面主要说一下styled components and styled system 使用中的一些问题</p><h4>2-4-1. insertRule</h4><p>styled components有一个insertRule 的后面
默认的时候，development mode是关闭insertRule, 这样你就可以在element的style中看到css inline styles
在production mode 会打开insertRule， 这样你就看不到了，但是会加快页面加载速度</p><p>这个后面是在webpack中配置一个process ENV</p><pre><code class="language-jsx">// 
// force the speed false for speedym true for no speedy
&#x27;process.env.REACT_APP_SC_DISABLE_SPEEDY&#x27;: true

</code></pre><p>我们发现build-storybook的时候找不到inline styles，本地server的时候可以看到，为什么呢？
其实就是因为storybook是基于webpack的，build-storybook就是production mode了，所以就隐藏了。</p><img src="/metaTrip/build/img/blog/b1.png" alt="" style="width:100%"/><h4>2-4-2. inherits styles</h4><p>styled components在继承属性这有一个坑，就是“as” prop会改变rendering target，
比如 styled(Comp)的target 是Comp， styled(div)或者styled.div的target是div，
如果在styled(Comp)上用as，那么就改变了target到div，也就失去了Comp中的样式继承。</p><p>官方文档推荐用forwardedAs 来替代就可以了
<a href="https://styled-components.com/docs/api#forwardedas-prop">https://styled-components.com/docs/api#forwardedas-prop</a></p><img src="/metaTrip/build/img/blog/b2.png" alt="" style="width:100%"/><h4>2-4-3. priority styles</h4><img src="/metaTrip/build/img/blog/b3.png" alt="" style="width:100%"/><p>下面的样式优先级应该是：</p><p>orange &gt; chocolate &gt; pink &gt; darkgreen &gt; yellow &gt; red &gt; blue</p><h4>2-4-4. flicker</h4><p>我在做组件库的过程中，在有些组件，比如tooltip，dropdown，datepicker的时候，
发现页面第一次加载的时候，打开menu，页面中文字会发生抖动现象，
只有第一次加载后会发生，然后再反复打开关闭menu，就不会发生了。</p><p>先说解决思路，排除法找到影响的代码，这些代码往往是menu中的具有styled components样式的组件
如果把这个组件提前再页面隐藏起来，就没有问题了</p><p>可能的原因就是styled components 这种css in js的方式，在组件没有render的时候，对应的inline style
也没有生成，当打开menu的时候，css inline style生成了，并且插入到了style中，这就产生了页面的重绘，
如果提前将样式加载进去，就不会产生页面重绘了，也就不会抖动了</p><h3>2-5. Rollup</h3><p>因为大家对webpack都比较了解，这里面简单说一下rollup。
<a href="https://medium.com/@PepsRyuu/why-i-use-rollup-and-not-webpack-e3ab163f4fd3">https://medium.com/@PepsRyuu/why-i-use-rollup-and-not-webpack-e3ab163f4fd3</a></p><p>Rollup for libraries, webpack for apps.
这个也不是绝对的，关键还是看需求。</p><p>如果项目需要代码拆分，或者有很多静态资源需要处理
再或者你构建的项目需要引入很多CommonJS模块的依赖，那就应该选择webpack</p><p>如果你的代码是基于ES模块的。而且你写的代码希望能够被其他项目直接使用
那么rollup可能更适合</p><p>简单来看下rollup配置</p><p>1.input， output.file和output.format都是必传的</p><pre><code class="language-jsx">// rollup 也支持配置多个文件入口

export default {
    input: {
        foo: &quot;./foo.js&quot;,
        bar: &quot;./bar.js&quot;
    },
    output: {
        dir: &quot;dist&quot;,
        format: &quot;cjs&quot;
    }
}

</code></pre><p>2.插件的配置比较简单，都是在plugin统一配置的</p><p>rollup默认只能加载es6的模块，所以需要commonjs模块，
我们引用node_mode中的第三方模块，需要用到rollup-plugin-mode-reslove来解析</p><p>3.rollup本身不支持启动开发服务器，需要通过第三方插件rollup-plugin-server来启动一个静态服务器</p><pre><code class="language-jsx">import serve from &quot;rollup-plugin-serve&quot;;
export default {
    input: &quot;./main.js&quot;,
    output： {
        file: &quot;dist/bundle.js&quot;,
        format: &quot;iife&quot;
    },
    plugins: [serve(&quot;dist&quot;)]
}

// 本质上是一个静态资源服务器，因此不支持模块热更新
</code></pre><p>4.Tree shaking</p><p>由于rollup本身支持ES6模块化规范，因此不需要额外配置即可进行tree shaking
不过如果你需要external依赖，需要注意子集module不会被filter掉，需要自定义</p><h3>2-6. style dictionary</h3><p>style dictionary 是一个theme 管理工具
他有丰富的接口，可以将json转化成各种项目需要的文档，
IOS, Android, css, js, html, sass，less 任何你需要的格式
这其实就为theme tokens的跨平台应用提供了可能。
<a href="https://amzn.github.io/style-dictionary/#/">https://amzn.github.io/style-dictionary/#/</a></p><h2>3. Design but not Only Design</h2><p>A公司有自己的一套design的标准，里面大概分两个部分，一个是foundation的部分
主要包括layout，RS(就是空间变化，padding，margin)，TS(字体变化，包括size，line-height, weight, letter-space),
breakpoints, color, icon等等。另一个部分就是各个组件的详细设计，但是设计单位都是要按照foundation进行的。</p><p>整体是一个theme的话，我们就可以把theme拆分成几个tokens。</p><p>1.Design tokens：就是design的基础定义，字体，颜色，空间这些，他们被Seman tokens使用</p><p>2.Semantic tokens：就是实际应用的语义，比如cta（default, hover, pressed, disabled），rag( error, warning, success, info)等等</p><p>3.UI tokens：组件用到的token， button, radio等等</p><img src="/metaTrip/build/img/blog/b4.png" alt="" style="width:100%"/><p>而Design tokens 和 Semantic tokens是可以用style dictionary来进行管理的，这样就实现了跨框架，跨平台的应用
实际上我们也实现了一个实际的例子，web/ios/Android 公用一套theme toolkit</p><p>这样设计，还带来了另一个好玩的东西，就是换肤，
你可以想象，组件逻辑不变，ui token不变，只是Semantic tokens 被不同的design token复写，那么就可以实现一套组件库，不同皮肤功能，
实际上这个poc也是完成了的。</p><p>所以整体上通过style dictionary管理theme，我们可以横向把foudation当作共同资源，跨框架和跨平台使用，纵向上通过换肤，扩展组件库应用范围</p><h2>4. 解耦和重用</h2><h3>4-1. UI组件开发的一些特点</h3><h4>4-1-1. 不要加入业务逻辑</h4><p>这个有的时候并不好分辨，尤其是对于新加的props，比如输入框的验证逻辑，需不需写在组件内部，
比如nls，那些是组件内部控制的，那些是业务逻辑。立场不同观点也不尽相同。
但是我们开发组件需要做个决定，而且标准前后要保持一致</p><h4>4-1-2. 组件接口要具有普遍性</h4><p>组件接口要适用大部分项目，要尽量简化。
不增加无意义的接口，比如我们之前iconlink 这个组件有mutiline这个接口，
就是link中内容在一行和两行中icon 样式不一样，所以先想当然的用mutiline来进行区分。</p><p>但是这个接口有意义么？没有意义，因为实际的项目中考虑到响应式布局，以及nls因素，单行和双行是不确定的
所以这个方法是行不通的</p><p>还有个例子，比如notification中title 有两种样式， 我们可以定义两个props, 比如title 用font h1，subtitle 用h2
但是这就有个问题，首先把title和subtitle font设定死，如果以后再扩展呢？title3？ title4？
另外我们考虑到title本身除了传string外，还可以是react.node, 所以title接口本身就可以实现title h1和subtitle h2的设计，
所以我们开始就不需要增加接口，只需要提供case，保持组件内部接口足够灵活和简单。</p><h4>4-1-3. 高标准</h4><p>这里面主要说的就是两个标准，design和accessibility</p><h4>4-1-4. Don&#x27;t cry over spilt milk</h4><p>如果写了不好的代码，尤其是接口，就需要继续维护，不能轻易删除
删除接口就会面临breaking changes，能不能删掉有时候不由组件开发者来决定。还要考虑到项目的影响。</p><h4>4-1-5. unknown impacts</h4><p>组件的发布，在做好自身质量把控的情况下，还有很多影响是未知的。
你不知道都有谁在用？你也不知道用户怎么用？
有时候发布上去，用户更新出了问题才知道，或者除了问题用户也不知道。比如很久之前的功能。</p><p>同时impacts也取决与用户更新版本的方式和频率。对于组件库来讲，最好的方式当然是，及时更新最新版本，并且严格使用cases中的标准写法。</p><h3>4-2. 解耦是为了提升复用率</h3><p>组件库内部代码不断演变，以及重构的方向，实际上就是不断解耦以及重用的过程。
整个组件库，或者说组件生态，会划分为五个级别。</p><p>从小到大分别是：逻辑，单个组件，视觉和行为，主题和组件库，以及依赖。</p><img src="/metaTrip/build/img/blog/b5.png" alt="" style="width:100%"/><h4>4-2-1.逻辑上讲</h4><p>作为developer，大家自然会去减少代码重复，提取公共变量，公共方法，工具方法等等</p><h4>4-2-2.组件层面，</h4><p>react本身的特点是component-based, compose components to build the complex UIs. 所以是一种搭积木的方式，
由简单到复杂的去进行开发。组件库内部的实现由两种，一种是在基础组件上构建新组件，比如dropdown，datepicker。有点像之前HOC的方式。
还有一种就是基础组件之间的组合，比如pagenation，iconbutton等等</p><h4>4-2-3.视觉和行为分离</h4><p>一个例子，button和link button，如果用composed components 来做，样式上要进行覆盖，代码并不友好。
划分不干净，后期维护impacts要考虑到button和link button 两个组件范围。实际中，UI视觉是可以有很多变化的，但是button行为，
以及a11y是要遵循一致性的，也就是native的特点。如果我们这样考虑将两者分类就会很干净。</p><p>另外也可以反过来，同样的视觉效果，但是行为是完全不一样的，比如pills。所以视觉和行为分离会带来很多好处，对于用户也更加灵活。
我们导出这些行为的hooks，用户可以直接使用，自定义UI。 类似与table，tooltip 都是如此，比如table，我们专注与UI，用户可以选择或者不用react-table
都没有问题</p><h4>4-2-4.主题和组件库分离</h4><p>这个在前面第三点(Design but not Only Design)有说过，theme是可以独立出来作为共享资源存在的，
而theme和组件库解绑，也有利于组件库本身的换肤，增大适用范围</p><h4>4-2-5.依赖</h4><p>组件库和chart库相互独立，包括开发，发布，下载相互没有依赖，
增大彼此的发展空间，更大的方向上，目前的组件库受到react版本限制，
组件库本身的用户有react16，17，还有18。但是我们如何支持18，这个问题会一致存在
我们如何打破这个限制也是下一步的方向</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[npm 快捷键]]></title>
            <link> https://777sunny777.github.io/metaTrip/metaTrip/build/blog/npm1</link>
            <guid>npm1</guid>
            <pubDate>Tue, 27 Dec 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[- 这篇blog是对npm常用命令的一些总结，会持续更新]]></description>
            <content:encoded><![CDATA[<p>:::tip</p><ul><li>这篇blog是对npm常用命令的一些总结，会持续更新
:::</li></ul><h2>1. 常用命令</h2><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>npm cache clean --force</td><td>clean npm cache</td></tr><tr><td>npm rm -rf node_modules &amp;&amp; rm package-lock.json</td><td>删除node node_modules文件夹以及lock文件</td></tr><tr><td>npm list</td><td>查看当前目录下已安装的node包</td></tr><tr><td>npm list -g</td><td>查看全局已经安装过的node包</td></tr><tr><td>npm config get prefix</td><td>查看全局安装路径</td></tr><tr><td>npm info</td><td>指定包名 : 查看远程npm上指定包的所有版本信息</td></tr><tr><td>npm root</td><td>查看当前包的安装路径</td></tr><tr><td>npm root -g</td><td>查看全局的包的安装路径</td></tr><tr><td>npm ls 包名</td><td>查看本地安装的指定包及版本信息，没有显示empty</td></tr><tr><td>npm ls包名 -g</td><td>查看全局安装的指定包及版本信息，没有显示empty</td></tr></tbody></table>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[vscode 快捷键]]></title>
            <link> https://777sunny777.github.io/metaTrip/metaTrip/build/blog/vscode1</link>
            <guid>vscode1</guid>
            <pubDate>Tue, 27 Dec 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[- 这篇blog是对vscode常用功能以及快捷键的一些总结，会持续更新]]></description>
            <content:encoded><![CDATA[<p>:::tip</p><ul><li>这篇blog是对vscode常用功能以及快捷键的一些总结，会持续更新
:::</li></ul><h2>1. typescript版本选择</h2><p>找到vscode中的ts/tsx文件，右下角有typescript当前版本</p><img src="/metaTrip/build/img/blog/vs1.png" alt="" style="width:100%"/><p>点击选择typescript version</p><img src="/metaTrip/build/img/blog/vs2.png" alt="" style="width:100%"/><p>从中进行选择</p><img src="/metaTrip/build/img/blog/vs3.png" alt="" style="width:100%"/><p>在terminal中run npx tsc -v 查看版本，这个版本是当前项目node_module中typescript的版本
如果是全局下，就是全局安装的版本</p><img src="/metaTrip/build/img/blog/vs4.png" alt="" style="width:100%"/><h2>2. 快捷键</h2><table><thead><tr><th>操作</th><th>描述</th></tr></thead><tbody><tr><td>ctrl + `</td><td>打开或关闭terminal</td></tr><tr><td>ctrl + enter</td><td>向下重开一行；</td></tr><tr><td>ctrl+shift + enter</td><td>则是在上一行重开一行</td></tr><tr><td>ctrl + x</td><td>剪切一行</td></tr><tr><td>ctrl +shift + k</td><td>直接删除一行</td></tr><tr><td>alt + ↑</td><td>向上移动一行</td></tr><tr><td>alt + ↓</td><td>向下移动一行</td></tr><tr><td>ctrl + f</td><td>搜索</td></tr><tr><td>Ctrl + Home</td><td>跳转到页头</td></tr><tr><td>Ctrl + End</td><td>跳转到页尾</td></tr><tr><td>Ctrl + /</td><td>添加关闭行注释</td></tr><tr><td>Shift + Alt +A</td><td>块区域注释</td></tr></tbody></table><h2>3. 有用的插件</h2><p>Git History</p><p>Import Cost</p><p>Markdown Preview Enhance</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[useMemo and useCallback, you really know it?]]></title>
            <link> https://777sunny777.github.io/metaTrip/metaTrip/build/blog/react2</link>
            <guid>react2</guid>
            <pubDate>Sun, 24 Apr 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[- 这篇blog是对useMemo 和 useCallback的深入学习。]]></description>
            <content:encoded><![CDATA[<p>:::tip</p><ul><li>这篇blog是对useMemo 和 useCallback的深入学习。
:::</li></ul><p>useMemo 和 useCallback 是react 提供的性能优化工具。用法比较简单，我们在项目中也知道要用，但是具体性能是如何提升的，是不是可以可视化出来，
相信有很多人并不是特别了解。这篇blog由此而生。</p><h2>1. useMemo</h2><p><strong> Returns a memoized value. </strong></p><p>返回一个<a href="https://reactjs.org/docs/hooks-reference.html#usememo">缓存值</a>, 这个是官网对useMemo描述的第一句话。如何理解这个缓存值就很关键，
实际上官网也提供了对应的维基百科的link。我把关键的面试copy到下面：</p><p>:::note
In computing, memoization or memoisation is an optimization technique used primarily to speed up computer programs by storing
the results of expensive funtion calls and returning the cached result when the same inputs occur again.
:::</p><p>所以我考虑再三，缓存值还是比较合适的，他的特点就是如果再有相同输入，那么就无需计算，直接返回缓存值即可，从未提升生代码性能。</p><p>我们再回到useMemo，Pass a “create” function and an array of dependencies.
useMemo will only recompute the memoized value when one of the dependencies has changed.
This optimization helps to avoid expensive calculations on every render.</p><p>它的参数是一个function(不是回调)和一个依赖数组。数组中的依赖发生变化才会触发函数中的计算。
如果官网的描述不是很清晰，下面是我从其他blog找到的一段更为清晰的一段useMemo描述。</p><p>:::note
React has a built-in hook called useMemo that allows you to memoize expensive functions
so that you can avoid calling them on every render. You simple pass in a function and an array of inputs
and useMemo will only recompute the memoized value when one of the inputs has changed.
:::</p><p>使用useMemo需要注意的几点：</p><p>:::tip</p><ol><li><p><strong>Don’t do anything there that you wouldn’t normally do while rendering.</strong> For example, side effects belong in useEffect, not useMemo.</p></li><li><p>If no array is provided, <strong>a new value will be computed on every render</strong>.</p></li><li><p>You may rely on useMemo as a performance optimization, <strong>not as a semantic guarantee</strong>. In the future, React may choose to “forget” some previously memoized values and recalculate them on next render, e.g. to free memory for offscreen components. <strong>Write your code so that it still works without useMemo</strong> — and then add it to optimize performance.
:::</p></li></ol><p>下面能我们就show case for useMemo，可视化的让大家可以体验一下他的性能提升。</p><p>测试方法：</p><ol><li><p>点击Next word，可以感受到由于复杂计算带来的延迟，点击Increment， 由于复杂计算被useMemo优化，所以感受不到延迟影响。
连续点击效果更明显。</p></li><li><p>注释掉下面useMemo代码，暴露复杂计算在render过程中。重复上面的动作，点击Increment的时候也出现延迟效果，实际上是不需要的。</p></li></ol><pre><code class="language-jsx" metastring="live">
function TestUseMemo() {

  // State for our counter
  const [count, setCount] = useState(0);
  
  // State to keep track of current word in array we want to show
  const [wordIndex, setWordIndex] = useState(0);
  
  // Words we can flip through and view letter count
  const words = [&quot;hey&quot;, &quot;this&quot;, &quot;is&quot;, &quot;cool&quot;];
  const word = words[wordIndex];
  
  // Returns number of letters in a word
  // We make it slow by including a large and completely unnecessary loop
  const computeLetterCount = (word) =&gt; {
    let i = 0;
    while (i &lt; 1000000000) i++;
    return word.length;
  };
  
  // Memoize computeLetterCount so it uses cached return value if input array ...
  // ... values are the same as last time the function was run.
  // 针对性的在需要的依赖下进行计算，其他的依赖改变的时候用cache数据，从而提升整体性能
  const letterCount = useMemo(() =&gt; computeLetterCount(word), [word]);
  
  // This would result in lag when incrementing the counter because ...
  // ... we&#x27;d have to wait for expensive function when re-rendering.
  //const letterCount = computeLetterCount(word);
  
  return (
    &lt;div style={{ padding: &quot;15px&quot; }}&gt;
      &lt;h2&gt;Compute number of letters (slow 🐌)&lt;/h2&gt;
      &lt;p&gt;
        &quot;{word}&quot; has {letterCount} letters
      &lt;/p&gt;
      &lt;button
        onClick={() =&gt; {
          const next = wordIndex + 1 === words.length ? 0 : wordIndex + 1;
          setWordIndex(next);
        }}
      &gt;
        Next word
      &lt;/button&gt;
      &lt;h2&gt;Increment a counter (fast ⚡️)&lt;/h2&gt;
      &lt;p&gt;Counter: {count}&lt;/p&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;Increment&lt;/button&gt;
    &lt;/div&gt;
  );
}

</code></pre><p><strong>所以结论就是在render中的复杂计算，需要useMemo来进行相关依赖下的性能优化。</strong></p><h2>1. useCallback</h2><p><strong> Returns a memoized callback.. </strong></p><p>返回一个<a href="https://reactjs.org/docs/hooks-reference.html#usecallback">缓存回调</a>, 我们可以对比上面的useMemo来看，这次缓存的实际上是我们的函数方法本身。</p><p>来看官网的解释，Pass an inline callback and an array of dependencies.
useCallback will return a memoized version of the callback that only changes if one of the dependencies has changed.
This is useful when passing callbacks to optimized child components that rely on reference equality
to prevent unnecessary renders (e.g. shouldComponentUpdate).</p><p>和useMemo的描述对比，这里面很明显告诉了我们什么时候用useCallback比较合适，就是shouldComponentUpdate之前什么时候用，现在你就可以考虑用useCallback。
下面是shouldComponentUpdate的官网描述。</p><p>:::note
Use shouldComponentUpdate() to let React know if a component’s output is not affected by the current change in state or props.
The default behavior is to re-render on every state change
:::</p><p>所以他是用来优化限制子组件渲染次数的。如果官网的描述不是很清晰，下面是我从其他blog找到的一段更为清晰的一段useCallback描述。</p><p>:::note
The useCallback hook is used when you have a component in which the child is rerendering again and again without need.
Pass an inline callback and an array of dependencies. useCallback will return a memoized version of the callback that only changes
if one of the dependencies has changed.
:::</p><p>使用useMemo需要注意的几点：</p><p>:::tip</p><ol><li><p>useCallback(fn, deps) is equivalent to useMemo(() =&gt; fn, deps)</p></li><li><p>useMemo和useCallBack, 在未来的react版本中，第二个参数，依赖数组是会被去掉的</p></li></ol><p>:::</p><p>下面能我们就show case for useCallback，可视化的让大家可以体验一下他的性能提升。</p><p>测试方法：</p><ol><li>代码中的funccount定义为</li></ol><pre><code class="language-jsx">let funccount = new Set();

// Set 对象是唯一值的集合，每个值在 Set 中只能出现一次。
// 如果对Set()定义不是和清楚，可以参考如下测试理解：
const set1 = new Set();

set1.add(1) 
set1.add(2)  
set1.add(3) 
set1.add(1) 

set1.size // 3
</code></pre><ol start="2"><li><p>需要F12，看console log的调用次数</p></li><li><p>点击如下三个按钮，在没有使用useCallBack的时候都是渲染3次累加，说明每次render3个方法都会被重新渲染到。</p></li><li><p>注释掉原有方法，打开useCallback的方法，再次观察渲染次数，会发现和依赖产生关系，没有触发的子组件也不会被渲染了。</p></li></ol><pre><code class="language-jsx" metastring="live">function TestUseCallback() {

  const [count, setCount] = useState(0)
  const [number, setNumber] = useState(0)
 
  const incrementCounter = () =&gt; {
    setCount(count + 1)
  }
  const decrementCounter = () =&gt; {
    setCount(count - 1)
  }
   
   const incrementNumber = () =&gt; {
    setNumber(number + 1)
  }

  /*
  const incrementCounter = useCallback(() =&gt; {
    setCount(count + 1)
  }, [count])

  const decrementCounter = useCallback(() =&gt; {
    setCount(count - 1)
  }, [count])

  const incrementNumber = useCallback(() =&gt; {
    setNumber(number + 1)
  }, [number])
  */ 

  funccount.add(incrementCounter);
  funccount.add(decrementCounter);
  funccount.add(incrementNumber);
  console.log(&#x27;funccount.size:&#x27; + funccount.size);
 
  return (
    &lt;div&gt;
      &lt;h2&gt;Count: {count}&lt;/h2&gt;
      &lt;h2&gt;Number: {number}&lt;/h2&gt;
      &lt;button onClick={incrementCounter}&gt;
         Increase counter
      &lt;/button&gt;
      &lt;button onClick={decrementCounter}&gt;
         Decrease Counter
      &lt;/button&gt;
      &lt;button onClick={incrementNumber}&gt;
         increase number
      &lt;/button&gt;
    &lt;/div&gt;
  )
}
 

</code></pre><p>总结就是useCallback针对函数缓存，主要限制子组件的渲染次数</p><p>后面我还会对Memo进行一个总结的。</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[我做自媒体小视频的一点感触]]></title>
            <link> https://777sunny777.github.io/metaTrip/metaTrip/build/blog/media</link>
            <guid>media</guid>
            <pubDate>Wed, 30 Mar 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[- From B站 桑尼孙先生]]></description>
            <content:encoded><![CDATA[<p>:::tip</p><ul><li>From B站 桑尼孙先生</li><li>大家快来关注我呀！么么哒！
:::</li></ul><iframe src="https://www.bilibili.com/video/BV1dL4y1F727?t=19.7" width="100%" height="800px"></iframe>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[如何挑选适合投资的指数基金]]></title>
            <link> https://777sunny777.github.io/metaTrip/metaTrip/build/blog/funding-basic5</link>
            <guid>funding-basic5</guid>
            <pubDate>Wed, 09 Mar 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[- From 《指数基金投资指南》章节4]]></description>
            <content:encoded><![CDATA[<p>:::tip</p><ul><li>From 《指数基金投资指南》章节4</li><li>小白学习，切勿盲目跟从
:::</li></ul><h2>1.格雷厄姆价值投资的3大理论</h2><p>格雷厄姆是巴菲特的老师，有两部著作《证券分析 Security Analysis》 和 《聪明的投资者》。
其价值投资核心在于“低估值价值投资+指数基金”。</p><h3>1-1.价格与价值的关系</h3><p>股票有其内在价值，股票的价格围绕其内在价值上下波动。
不过虽然股价在短期内会暴涨暴跌，但长期表现还是会与股票的内在价值趋于一致。</p><h3>1-2.能力圈</h3><p>我们对所投资的品种非常了解，能判断出它大概的内在价值是多少。
我们对品种了解的越多, 内力圈也就越大，前提是我们真的了解。</p><p>巴菲特的解释是：你的能力圈，最重要的不是圈的大小，而是你知道自己的能力圈的边界所在。</p><p>后面的估值测算，解决了一部分能力圈的问题。</p><h3>1-3.安全边际</h3><p>我们要用0.4元买价值1元的东西，这个就是安全边界的核心。
我们要用比价值更低的价格去买股票。当价格大幅低于股票的内在价值的时候，这时投资才具备安全边界。</p><h2>2.估值</h2><p>我们如何知道基金的价格是不是低于价值？这就需要一些估值方法来帮助我们进行判断。</p><h3>2-1.常见的估值指标</h3><p>:::note
市盈率：公司市值/公司盈利</p><ul><li>静态市盈率：公司盈利取用公司上一年度的净利润</li><li>滚动市盈率：取用最近4个季度财报的净利润</li><li>动态市盈率：取用预估的公司下一季度净利润</li></ul><p>市盈率反应了我们愿意为获取1元的净利润付出多少代价</p><p>市值代表了我们买下这个公司理论上需要多少资金量</p><p>这个指标适用于流通性好，盈利稳定的品种。
:::</p><p>:::note
盈利收益率：市盈率的倒数， 盈利收益率高，股息率就高。市盈率就低
:::</p><p>:::note
市净率：每股股价与每股净资产的比率，公司市值/公司净资产</p><p>净资产就是资产减去负债
:::</p><p>:::note
股息率：过去一年公司的现金分红/公司的市值，随着股价波动，股价越低，股息率越高</p><p>分红率（派息率）：过去一年公司的现金分红/公司的总净利润，一般是公司预先设置好，多年不变
:::</p><h3>2-2.查询指数估计的方式</h3><p>公众号：定投十年赚十倍</p><p>指数官网查询：中证指数官网可查</p><p>还有就是收费的金融终端，一般不太需要</p><h2>3.挑选指数基金的两大策略</h2><h3>3-1. 盈利收益率法</h3><ul><li>当盈利收益率大于10%时，开始定投</li><li>当盈利收益率小于10%时，停止定投，坚定持有</li><li>当盈利收益率小于6.4%时，分批卖出指数基金，换成其他品种，分批卖出风险更低</li></ul><p>一般情况下，盈利收益率变化不大，收益大概在（15% -- 20%）</p><p>局限性：只适用于盈利稳定的价值指数，上证红利，中证红利，上证50，基本面50，上证50AH优选，央视50。</p><h3>3-2. 博格公式法</h3><p>公式计算比较绕，只说结论：</p><ul><li>在股息率高的时候买入</li><li>在市盈率处于历史较低位置时买入</li><li>买入后耐心等待“均值回归”，即市盈率从低到高。</li></ul>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[useEffect，you really know it?]]></title>
            <link> https://777sunny777.github.io/metaTrip/metaTrip/build/blog/react1</link>
            <guid>react1</guid>
            <pubDate>Tue, 08 Mar 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[- 这篇blog是对useEffect及相关hooks的深入学习。]]></description>
            <content:encoded><![CDATA[<p>:::tip</p><ul><li>这篇blog是对useEffect及相关hooks的深入学习。
:::</li></ul><p><a href="https://reactjs.org/docs/hooks-effect.html">Using the Effect Hook</a> 对于常用的react hooks我一直认为是比较了解的，然而最近的一次项目组sharing，
讨论到这块，居然发现这么常用的hook自己的理解竟然是有偏差的，还需要去深入的学习一下。这篇blog由此而来。</p><h2>1. useEffect</h2><p>:::note
If you’re familiar with React class lifecycle methods, you can think of useEffect Hook as componentDidMount, componentDidUpdate, and componentWillUnmount combined.</p><p>我们常规的理解，useEffect应该就是之前class component生命周期中componentDidMount, componentDidUpdate, and componentWillUnmount的结合
:::</p><p>react组件中有两种常见的side effects，一种需要clearup, 一种不需要，具体如下。</p><h3>1-1. Effects Without Cleanup</h3><p>在一些情况下，我们需要运行额外的代码在react更新dom结构之后，比如ajax 请求，手动更改dom结构，后者logging的时候。
这些情况是不需要cleanup的。</p><p>我们看下面的例子：</p><pre><code class="language-jsx">class Example extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      count: 0
    };
  }

  componentDidMount() {
    document.title = `You clicked ${this.state.count} times`;
  }
  componentDidUpdate() {
    document.title = `You clicked ${this.state.count} times`;
  }

  render() {
    return (
      &lt;div&gt;
        &lt;p&gt;You clicked {this.state.count} times&lt;/p&gt;
        &lt;button onClick={() =&gt; this.setState({ count: this.state.count + 1 })}&gt;
          Click me
        &lt;/button&gt;
      &lt;/div&gt;
    );
  }
}
</code></pre><p>用class component来写的时候，我们需要用到两个生命周期函数， componentDidMount在初始render的时候触发，componentDidUpdate在每次update的时候触发
无论如何优化代码， <strong>we have to duplicate the code between these two lifecycle methods in class</strong>，我想这也是我们后面用hooks来代替的原因之一。</p><p>如果我们用Hooks来写呢</p><pre><code class="language-jsx" metastring="live">function Example() {
  const [count, setCount] = useState(0);

  useEffect(() =&gt; {
    console.log(&#x27;demo1 useEffect running&#x27;);
    document.title = `You clicked ${count} times`;
  });

  return (
    &lt;div&gt;
      &lt;p&gt;You clicked {count} times&lt;/p&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;
        Click me
      &lt;/button&gt;
    &lt;/div&gt;
  );
}
</code></pre><p>默认情况下，useEffect会在第一次render以及后面每次update的时候触发，我们不需要考虑mounting还是updateing。
it will remember the effect we used, and then run our effect after updating the DOM. This happens for every render, including the first one.</p><h3>1-2. Effects With Cleanup</h3><p>一般比较常见的需要cleanup的例子，有建立取消定时器，防止内存溢出等等，我们看react 官网class component with cleanup的例子：</p><pre><code class="language-jsx">class FriendStatus extends React.Component {
  constructor(props) {
    super(props);
    this.state = { isOnline: null };
    this.handleStatusChange = this.handleStatusChange.bind(this);
  }

  componentDidMount() {
    ChatAPI.subscribeToFriendStatus(
      this.props.friend.id,
      this.handleStatusChange
    );
  }
  componentWillUnmount() {
    ChatAPI.unsubscribeFromFriendStatus(
      this.props.friend.id,
      this.handleStatusChange
    );
  }
  handleStatusChange(status) {
    this.setState({
      isOnline: status.isOnline
    });
  }

  render() {
    if (this.state.isOnline === null) {
      return &#x27;Loading...&#x27;;
    }
    return this.state.isOnline ? &#x27;Online&#x27; : &#x27;Offline&#x27;;
  }
}
</code></pre><p>其中componentDidMount 和 componentWillUnmount 是互为镜像的。
如果我们用Hooks来写呢，需要return一个function，react会在cleanup的时候调用</p><pre><code class="language-jsx" metastring="live">function FriendStatus(props) {
  const [isOnline, setIsOnline] = useState(null);

  useEffect(() =&gt; {
    function handleStatusChange(status) {
      setIsOnline(status.isOnline);
    }
    
    console.log(&#x27;demo2 useEffect running&#x27;);
    // comment since we have no ChatAPI here, just for demo
    // ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);

    // Specify how to clean up after this effect:
    // We don’t have to return a named function from the effect. 
    // We called it cleanup here to clarify its purpose, but you could return an arrow function or call it something different.
    return function cleanup() {
      console.log(&#x27;demo2 cleanup running&#x27;);
      // ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);
    };
  });

  return (
      &lt;&gt;
        &lt;p&gt; {isOnline ? &#x27;Online&#x27; : &#x27;Offline&#x27;} &lt;/p&gt;
        &lt;button onClick={ ()=&gt;setIsOnline(&#x27;online&#x27;) } &gt;Online&lt;/button&gt;
        &lt;button onClick={ ()=&gt;setIsOnline(null) }&gt;Offline&lt;/button&gt;
      &lt;/&gt;
  )
}
</code></pre><p>:::tip
试想，如果此时你尝试着去点击online和offline的button，那么此时的return会不会被调用？</p><p>按照文档return应该是在cleanup的时候调用的，那么state变化了，会触发cleanup么？
:::</p><p>我就是在这个地方出现理解的错误，我认为state变化是不会触发cleanup的，只有在dom结构删除了的时候，也就是ummount的时候才会触发一次。
但是测试结果和我想得完全不同，每次state变化，都会先触发cleanup，然后在触发side effect。</p><p>大家可以在上面的live demo中尝试，console里有记录可查。</p><p>然后我查找文档，发现了这么两段话。</p><p>:::tip
Why did we return a function from our effect?</p><p>This is the optional cleanup mechanism for effects. Every effect may return a function that cleans up after it.
This lets us keep the logic for adding and removing subscriptions close to each other. They’re part of the same effect!
:::</p><p>:::tip
When exactly does React clean up an effect?</p><p>React performs the cleanup when the component unmounts. However, as we learned earlier, effects run for every render and not just once.
This is why React also cleans up effects from the previous render before running the effects next time. （这就是为什么React还会在下次运行效果之前清除上一次渲染的效果）
We’ll discuss why this helps avoid bugs and how to opt out of this behavior in case it creates performance issues later below.
:::</p><p>第一段话关键在于告诉我们return是每个effect中都存在的机制，<strong>不管你使用不使用，他都是effect的一部分</strong>。</p><p>第二句话关键在于告诉我们<strong>因为effect是多次运行的，所以return里的cleanup也是多次运行的</strong>，这样做是有原因的：1.避免bugs. 2.可以有退出机制。</p><h2>2. Tips for Using Effects</h2><h3>2-1. Tip: Use Multiple Effects to Separate Concerns</h3><p>Hooks let us split the code based on what it is doing rather than a lifecycle method name.
不同的逻辑分在不同的useEffect里面，是得逻辑结构更清晰，这个应该是选择hooks的原因之二。</p><pre><code class="language-jsx">function FriendStatusWithCounter(props) {
  const [count, setCount] = useState(0);
  useEffect(() =&gt; {
    document.title = `You clicked ${count} times`;
  });

  const [isOnline, setIsOnline] = useState(null);
  useEffect(() =&gt; {
    function handleStatusChange(status) {
      setIsOnline(status.isOnline);
    }

    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);
    return () =&gt; {
      ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);
    };
  });
  // ...
}
</code></pre><p>:::tip
Explanation: Why Effects Run on Each Update?</p><p>If you’re used to classes, you might be wondering why the effect cleanup phase happens after every re-render,
and not just once during unmounting. Let’s look at a practical example to see why this design helps us create components with fewer bugs.</p><p>之前的误解原因使用class component的后遗症，effect的机制是cleanup每次都会触发，react这样设计的原因是为了减少bugs</p><p>This behavior ensures consistency by default and prevents bugs that are common in class components due to <strong>missing update logic</strong>.
:::</p><p>官方的例子是关于好友在线状态的，在props更新的情况下，好友A可能被好友B替代，但是如下的例子就会显示好友B在线，但是B可能不在线。</p><pre><code class="language-jsx">  componentDidMount() {
    ChatAPI.subscribeToFriendStatus(
      this.props.friend.id,
      this.handleStatusChange
    );
  }

  componentWillUnmount() {
    ChatAPI.unsubscribeFromFriendStatus(
      this.props.friend.id,
      this.handleStatusChange
    );
  }
</code></pre><p>我们可以通过compoentDidUpdate进行解决，判断props变化了之后，关掉前一个好友A的链接，重新建立新好友B的链接，而现实中我们可能经常忘了添加这个逻辑。
所以用useEffect，每次都会cleanup前一次的记录，然后重新开始effect update。</p><pre><code class="language-jsx">  componentDidMount() {
    ChatAPI.subscribeToFriendStatus(
      this.props.friend.id,
      this.handleStatusChange
    );
  }

  componentDidUpdate(prevProps) {
    // Unsubscribe from the previous friend.id
    ChatAPI.unsubscribeFromFriendStatus(
      prevProps.friend.id,
      this.handleStatusChange
    );
    // Subscribe to the next friend.id
    ChatAPI.subscribeToFriendStatus(
      this.props.friend.id,
      this.handleStatusChange
    );
  }

  componentWillUnmount() {
    ChatAPI.unsubscribeFromFriendStatus(
      this.props.friend.id,
      this.handleStatusChange
    );
  }

</code></pre><h3>2-2. Tip: Optimizing Performance by Skipping Effects</h3><p>In some cases, cleaning up or applying the effect after every render might create a performance problem.
In class components, we can solve this by writing an extra comparison with prevProps or prevState inside componentDidUpdate</p><pre><code class="language-jsx">componentDidUpdate(prevProps, prevState) {
  if (prevState.count !== this.state.count) {
    document.title = `You clicked ${this.state.count} times`;
  }
}
</code></pre><p>在hooks中如何处理呢：</p><pre><code class="language-jsx" metastring="live">function Example() {
  const [count, setCount] = useState(0);
  const [count2, setCount2] = useState(100);

  useEffect(() =&gt; {
    console.log(&#x27;demo3 useEffect running&#x27;);
    document.title = `You clicked ${count} times`;
    
    return () =&gt; {
      console.log(&#x27;demo3 cleanup running&#x27;);
    };
  }, [count]);

  return (
    &lt;div&gt;
      &lt;p&gt;You clicked {count} times, click {count2} times&lt;/p&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;
        Click me +
      &lt;/button&gt;
      &lt;button onClick={() =&gt; setCount2(count2 - 1)}&gt;
        Click me -
      &lt;/button&gt;
    &lt;/div&gt;
  );
}
</code></pre><p>这个例子告诉我们，useEffect只接受count 变化的case，对count2变化是不处理的。当然cleanup也是会处理每次count的更新。而不是接受所有的props更新。
<strong>也就是通过选择监控的props，过滤掉多余render的触发。</strong></p><h3>2-3. Others</h3><p>:::tip
If you use this optimization, make sure the array includes all values from the component scope (such as props and state)
that change over time and that are used by the effect. </p><p>Otherwise, your code will reference stale values from previous renders.
:::</p><p>:::tip
If you want to run an effect and clean it up only once (on mount and unmount), you can pass an empty array ([]) as a second argument.
This tells React that your effect doesn’t depend on any values from props or state, so it never needs to re-run.</p><p>If you pass an empty array ([]), the props and state inside the effect will always have their initial values.
While passing [] as the second argument is closer to the familiar componentDidMount and componentWillUnmount mental model,</p><p>Also, don’t forget that React defers running useEffect until after the browser has painted, so doing extra work is less of a problem.
:::</p><h2>3. useLayoutEffect</h2><p>The signature is identical to useEffect, but it fires synchronously after all DOM mutations.
Use this to read layout from the DOM and synchronously re-render. Updates scheduled inside useLayoutEffect will be flushed synchronously,
before the browser has a chance to paint.</p><p>我目前的理解，useEffect是异步的，在浏览器渲染完成之后进行。而useLayoutEffect是同步的，在浏览器渲染前更新，是block浏览器渲染进程的。</p><p>useLayoutEffect 无论代码先后都是在useEffect前执行的。</p><pre><code class="language-jsx" metastring="live">function Example() {
  const [count, setCount] = useState(0);

  useEffect(() =&gt; {
    console.log(&#x27;demo4 useEffect after render&#x27;);
    document.title = `You clicked ${count} times`;
    
    return ()=&gt;{
        console.log(&#x27;demo4 cleanup running&#x27;);
    }
  });

  useLayoutEffect(() =&gt; {
    console.log(&#x27;demo4 useLayoutEffect running&#x27;);

    return ()=&gt;{
        console.log(&#x27;demo4 useLayoutEffect cleanup running&#x27;);
    }
  });

  console.log(&#x27;demo4 update DOM&#x27;);

  return (
    &lt;div&gt;
      &lt;p&gt;You clicked {count} times&lt;/p&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;
        Click me
      &lt;/button&gt;
    &lt;/div&gt;
  );
}
</code></pre><p>:::tip
useEffect 是异步非阻塞调用</p><p>useLayoutEffect 是同步阻塞调用</p><p>useEffect 浏览器绘制后</p><p>useLayoutEffect 在 DOM 变更（React 的更新）后，浏览器绘制前完成所有操作
:::</p><p>0，7，之后暂停1秒，出现5，说明layoutEffect阻塞了useEffect。</p><pre><code class="language-jsx" metastring="live">function FuncCom () {
    const [counter, setCounter] = useState(0);

    useEffect(() =&gt; {
        if (counter === 2) {
            setCounter(5)
        }
    });

    useLayoutEffect(() =&gt; {
        if (counter === 7) {
            setTimeout(()=&gt;{
                setCounter(2)
            }, 1000);
        }
    });

    return (
        &lt;div style={{fontSize: &#x27;40px&#x27;}}&gt;
            &lt;button onClick={() =&gt; setCounter(7)}&gt;{counter}&lt;/button&gt;
        &lt;/div&gt;
    )
}
</code></pre>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Micro FrontEnd Basic]]></title>
            <link> https://777sunny777.github.io/metaTrip/metaTrip/build/blog/microFE1</link>
            <guid>microFE1</guid>
            <pubDate>Wed, 26 Jan 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[- 这是我对于MFE比较系统学习记录的首篇blog]]></description>
            <content:encoded><![CDATA[<p>:::tip</p><ul><li>这是我对于MFE比较系统学习记录的首篇blog </li><li>主要参考的Cam Jackson的文章<a href="https://martinfowler.com/articles/micro-frontends.html">Micro Frontends</a>
:::</li></ul><p>Cam Jackson 是Thoughtworks的全栈工程师，这篇文章虽然出自2019年，但是对于MFE概念的初学者还是友好的，可以比较容易的理解。
相应的文章最后还提供了MEF的example, 按照文章顺序去学习，应该可以很快入门。我的这篇blog，算是对他的文章和我一点经验的总结，
我们直接步入正题。</p><h2>1. Micro Frontends</h2><p>&quot;An architectural style where independently deliverable frontend applications are composed into a greater whole&quot;</p><p>这是Cam Jackson 或者说是Thoughtworks对MFE的定义。我们从中可以提取到两个重点：</p><ul><li>independently deliverable. 独立交付</li><li>composed into a greater whole. 组合构成整体</li></ul><h3>1-1. MFE cost</h3><p>因为后面我们要详细解读下MFE的Benefits，所以这里主要是先将一下他的cost：</p><p>:::note
there are no free lunches when it comes to software architecture - everything comes with a cost.</p><ul><li>Some micro frontend implementations can lead to duplication of dependencies</li><li>increasing the number of bytes our users must download</li><li>the dramatic increase in team autonomy can cause fragmentation in the way your teams work</li></ul><p>Nonetheless, we believe that these risks can be managed, and that the benefits of micro frontends often outweigh the costs
:::</p><p>总体来说，MFE可能会导致依赖重复，增加了需要download的asset，还有就是独立团队工作方式上的一些挑战。对于结论Thoughtworks认为总体上MFE还是利大于弊的。
我们接下来说说Benefits。</p><h2>2. Benefits</h2><h3>2-1. Incremental upgrades(增量升级)</h3><p>The endgame here is that we&#x27;re afforded more freedom to make case-by-case decisions on individual parts of our product,
and to make incremental upgrades to our architecture, our dependencies, and our user experience.
If there is a major breaking change in our main framework, each micro frontend can be upgraded whenever it makes sense,
rather than being forced to stop the world and upgrade everything at once. If we want to experiment with new technology,
or new modes of interaction, we can do it in a more isolated fashion than we could before.</p><p>好处之一就是MFE的子模块升级是自主的，并且与主模块解耦，即主模块有过有些大的major breaking changes，子模块也不需要和主模块同步进行修改和升级。
而是可以选择一个自身合适的时机来进行升级。</p><p>:::tip
这里面我的理解是：主模块的以来还是会default影响MFE的子模块的，但是子模块自身可以选择要不要这种影响，即依赖主模块的依赖，
或者关闭主模块依赖而只选择自身的依赖，这样就比较灵活和自主了。这条我会在后面进行相应的印证。
:::</p><h3>2-2. Simple, decoupled codebases(简单，解耦)</h3><p>These smaller codebases tend to be simpler and easier for developers to work with.
In particular, we avoid the complexity arising from unintentional and inappropriate coupling between components
that should not know about each other. </p><p>micro frontends push you to be explicit and deliberate about how data and events flow
between different parts of the application, which is something that we should have been doing anyway!</p><p>MFE一定是小而精的，尽量减少组件间数据或事件传输，这一点需要我们深入的思考。</p><h3>2-3. Independent deployment(独立部署)</h3><p>Just as with microservices, independent deployability of micro frontends is key.
This reduces the scope of any given deployment, which in turn reduces the associated risk.
Regardless of how or where your frontend code is hosted, each micro frontend should have
its own continuous delivery pipeline, which builds, tests and deploys it all the way to production.
We should be able to deploy each micro frontend with very little thought given to the current state of
other codebases or pipelines. It shouldn&#x27;t matter if the old monolith is on a fixed, manual,
quarterly release cycle, or if the team next door has pushed a half-finished or broken feature into their master branch.
If a given micro frontend is ready to go to production, it should be able to do so, and that decision
should be up to the team who build and maintain it.</p><p>MFE是需要对立进行build，test和deploy到production的，这个也是其主要特征之一，也是一般项目进行MFE架构重构的主要目的。</p><img src="/metaTrip/build/img/blog/deployment.png" alt="" style="width:100%"/><h3>2-4. Autonomous teams(自治团队)</h3><p>Teams can have full ownership of everything they need to deliver value to customers,
which enables them to move quickly and effectively</p><p>依赖越少，响应越灵活。这个和第三条比较相辅相成。</p><img src="/metaTrip/build/img/blog/horizontal.png" alt="" style="width:100%"/><h2>3. Integration approaches</h2><p>:::note
there is a micro frontend for each page in the application, and there is a single container application, which:</p><ul><li>renders common page elements such as headers and footers</li><li>addresses cross-cutting concerns like authentication and navigation</li><li>brings the various micro frontends together onto the page, and tells each micro frontend when and where to render itself
:::</li></ul><img src="/metaTrip/build/img/blog/composition.png" alt="" style="width:100%"/><h3>3-1. Server-side template composition</h3><p>rendering HTML on the server out of multiple templates or fragments.
We have an index.html which contains any common page elements,
and then uses server-side includes to plug in page-specific content from fragment HTML files</p><pre><code class="language-jsx">&lt;html lang=&quot;en&quot; dir=&quot;ltr&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;Feed me&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;🍽 Feed me&lt;/h1&gt;
    &lt;!--# include file=&quot;$PAGE.html&quot; --&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre><pre><code class="language-jsx">server {
    listen 8080;
    server_name localhost;

    root /usr/share/nginx/html;
    index index.html;
    ssi on;

    # Redirect / to /browse
    rewrite ^/$ http://localhost:8080/browse redirect;

    # Decide which HTML fragment to insert based on the URL
    location /browse {
      set $PAGE &#x27;browse&#x27;;
    }
    location /order {
      set $PAGE &#x27;order&#x27;;
    }
    location /profile {
      set $PAGE &#x27;profile&#x27;
    }

    # All locations should render through index.html
    error_page 404 /index.html;
}
</code></pre><p>This example shows how micro frontends is not necessarily a new technique,
and does not have to be complicated.
As long as we&#x27;re careful about how our design decisions affect the autonomy of our codebases and our teams, we can achieve many of the same benefits regardless of our tech stack.</p><p>实际上这个例子只是要告诉我们，MFE是一种思想，并不是一个新的技术，或者需要新的技术才可以实现。
只要满足独立交付，组合构成整体都应该是MFE的范畴。</p><h3>3-2. Build-time integration</h3><p>One approach that we sometimes see is to publish each micro frontend as a package,
and have the container application include them all as library dependencies.
Here is how the container&#x27;s package.json might look for our example app:</p><pre><code class="language-jsx">{
  &quot;name&quot;: &quot;@feed-me/container&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;description&quot;: &quot;A food delivery web app&quot;,
  &quot;dependencies&quot;: {
    &quot;@feed-me/browse-restaurants&quot;: &quot;^1.2.3&quot;,
    &quot;@feed-me/order-food&quot;: &quot;^4.5.6&quot;,
    &quot;@feed-me/user-profile&quot;: &quot;^7.8.9&quot;
  }
}
</code></pre><p>component ui library 框架就是一种build-time的模式。他的引用是基于package的，依赖的形式存在。
很多大的项目也是这种假的MFE开发方式。</p><p>At first this seems to make sense. It produces a single deployable Javascript bundle,
as is usual, allowing us to de-duplicate common dependencies from our various applications.
However, this approach means that we have to re-compile and release every single micro frontend
in order to release a change to any individual part of the product. Just as with microservices,
we&#x27;ve seen enough pain caused by such a lockstep release process that we would recommend
strongly against this kind of approach to micro frontends.</p><p>这种方式的不合理之处就在于compile和release都需要同步进行，这个和MFE独立交付的概念是绝对相反的，是反MFE的一种方式。
We should find a way to integrate our micro frontends at run-time, rather than at build-time.</p><h3>3-3. Run-time integration via iframes</h3><p>One of the simplest approaches to composing applications together in the browser is the humble iframe.
By their nature, iframes make it easy to build a page out of independent sub-pages.
They also offer a good degree of isolation in terms of styling and global variables not interfering with each other.</p><pre><code class="language-jsx">&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Feed me!&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Welcome to Feed me!&lt;/h1&gt;

    &lt;iframe id=&quot;micro-frontend-container&quot;&gt;&lt;/iframe&gt;

    &lt;script type=&quot;text/javascript&quot;&gt;
      const microFrontendsByRoute = {
        &#x27;/&#x27;: &#x27;https://browse.example.com/index.html&#x27;,
        &#x27;/order-food&#x27;: &#x27;https://order.example.com/index.html&#x27;,
        &#x27;/user-profile&#x27;: &#x27;https://profile.example.com/index.html&#x27;,
      };

      const iframe = document.getElementById(&#x27;micro-frontend-container&#x27;);
      iframe.src = microFrontendsByRoute[window.location.pathname];
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre><p>It can be difficult to build integrations between different parts of the application,
so they make routing, history, and deep-linking more complicated,
and they present some extra challenges to making your page fully responsive.</p><p>iframes觉得是MFE最简单的实现方式，我们主要考虑到灵活性的一些问题而不去采用它。比如responsive的实现就很困难。</p><h3>3-4. Run-time integration via JavaScript(主要实现方式)</h3><p>probably the most flexible one, and the one that we see teams adopting most frequently.
Each micro frontend is included onto the page using a <strong>script</strong> tag, and upon load exposes a global function as its entry-point.
The container application then determines which micro frontend should be mounted,
and calls the relevant function to tell a micro frontend when and where to render itself.</p><pre><code class="language-jsx">&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Feed me!&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Welcome to Feed me!&lt;/h1&gt;

    &lt;!-- These scripts don&#x27;t render anything immediately --&gt;
    &lt;!-- Instead they attach entry-point functions to `window` --&gt;
    &lt;script src=&quot;https://browse.example.com/bundle.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;https://order.example.com/bundle.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;https://profile.example.com/bundle.js&quot;&gt;&lt;/script&gt;

    &lt;div id=&quot;micro-frontend-root&quot;&gt;&lt;/div&gt;

    &lt;script type=&quot;text/javascript&quot;&gt;
      // These global functions are attached to window by the above scripts
      const microFrontendsByRoute = {
        &#x27;/&#x27;: window.renderBrowseRestaurants,
        &#x27;/order-food&#x27;: window.renderOrderFood,
        &#x27;/user-profile&#x27;: window.renderUserProfile,
      };
      const renderFunction = microFrontendsByRoute[window.location.pathname];

      // Having determined the entry-point function, we now call it,
      // giving it the ID of the element where it should render itself
      renderFunction(&#x27;micro-frontend-root&#x27;);
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre><p>The above is obviously a primitive example, but it demonstrates the basic technique.
Unlike with build-time integration, we can deploy each of the bundle.js files independently.
And unlike with iframes, we have full flexibility to build integrations between our micro frontends however we like.
We could extend the above code in many ways, for example to only download each JavaScript bundle as needed,
or to pass data in and out when rendering a micro frontend.The flexibility of this approach, combined with the independent
deployability, makes it our default choice, and the one that we&#x27;ve seen in the wild most often.</p><p>这种方式与iframe相比，可以解决子模块间的同步协作问题，比如responsive。与build-time相比，可以独立交付。而且还可以按需加载。
所以成为了MFE实现的最主要方式。</p><h3>3-5. Run-time integration via Web Components</h3><p> for each micro frontend to define an HTML custom element for the container to instantiate,
instead of defining a global function for the container to call.</p><pre><code class="language-jsx">&lt;html&gt;
 &lt;head&gt;
   &lt;title&gt;Feed me!&lt;/title&gt;
 &lt;/head&gt;
 &lt;body&gt;
   &lt;h1&gt;Welcome to Feed me!&lt;/h1&gt;

   &lt;!-- These scripts don&#x27;t render anything immediately --&gt;
   &lt;!-- Instead they each define a custom element type --&gt;
   &lt;script src=&quot;https://browse.example.com/bundle.js&quot;&gt;&lt;/script&gt;
   &lt;script src=&quot;https://order.example.com/bundle.js&quot;&gt;&lt;/script&gt;
   &lt;script src=&quot;https://profile.example.com/bundle.js&quot;&gt;&lt;/script&gt;

   &lt;div id=&quot;micro-frontend-root&quot;&gt;&lt;/div&gt;

   &lt;script type=&quot;text/javascript&quot;&gt;
     // These element types are defined by the above scripts
     const webComponentsByRoute = {
       &#x27;/&#x27;: &#x27;micro-frontend-browse-restaurants&#x27;,
       &#x27;/order-food&#x27;: &#x27;micro-frontend-order-food&#x27;,
       &#x27;/user-profile&#x27;: &#x27;micro-frontend-user-profile&#x27;,
     };
     const webComponentType = webComponentsByRoute[window.location.pathname];

     // Having determined the right web component custom element type,
     // we now create an instance of it and attach it to the document
     const root = document.getElementById(&#x27;micro-frontend-root&#x27;);
     const webComponent = document.createElement(webComponentType);
     root.appendChild(webComponent);
   &lt;/script&gt;
 &lt;/body&gt;
&lt;/html&gt;
</code></pre><p>the main difference being that you are opting in to doing things &#x27;the web component way&#x27;.
If you like the web component spec, and you like the idea of using capabilities that the browser provides,
then this is a good option. If you prefer to define your own interface between the container
application and micro frontends, then you might prefer the previous example instead.</p><p>如果不需要考虑IE浏览器，也是一个很好的选择。</p><h2>4. Styling</h2><p>In a micro frontends landscape, many of these problems are exacerbated. For example,
if one team&#x27;s micro frontend has a stylesheet that says h2 { color: black; },
and another one says h2 { color: blue; }, and both these selectors are attached to the same page,
then someone is going to be disappointed! This is not a new problem,
but it&#x27;s made worse by the fact that these selectors were written by different teams at different times,
and the code is probably split across separate repositories, making it more difficult to discover.</p><p>:::tip
MFE主要是解决css的样式重名问题，目前的css有多种写法来避免这个问题， BEM，sass/less, css in js.
我目前对这个具体的解决方式还有待理解，后面我会去印证一下。
:::</p><h2>5. Shared component libraries</h2><p>We mentioned above that visual consistency across micro frontends is important,
and one approach to this is to develop a library of shared, re-usable UI components.
In general we believe that this a good idea, although it is difficult to do well.
The main benefits of creating such a library are reduced effort through re-use of code,
and visual consistency. In addition, your component library can serve as a living styleguide,
and it can be a great point of collaboration between developers and designers.</p><p>简单来说，MFE也是需要同意视觉UI 标准的，这趋势就需要一个component ui 库来支持。比如mui，bootstrap。
或者是项目自建，自建的方式可以是从多个子模块中抽取common的组件。而不用day1的时候就构建。
但是这个component ui 库是需要的。 </p><p>:::tip
我需要在项目中进一步印证一下。比如BRP和New UI MFE的关系
:::</p><h2>6. Cross-application communication</h2><p>One of the most common questions regarding micro frontends is <strong>how to let them talk to each other</strong>.
In general, we recommend having them communicate as little as possible,
as it often reintroduces the sort of inappropriate coupling that we&#x27;re seeking to avoid in the first place.</p><p>That said, some level of cross-app communication is often needed. </p><ul><li>Custom events allow micro frontends to communicate indirectly, which is a good way to minimise direct coupling,
though it does make it harder to determine and enforce the contract that exists between micro frontends. </li><li>Alternatively, the React model of passing callbacks and data downwards (in this case downwards from the container
application to the micro frontends) is also a good solution that makes the contract more explicit. </li><li>A third alternative is to use the address bar as a communication mechanism.</li></ul><p>Whatever approach we choose, we want our micro frontends to communicate by sending messages or events to each other,
and avoid having any shared state. </p><p>Just like sharing a database across microservices, as soon as we share our data structures and domain models,
we create massive amounts of coupling, and it becomes extremely difficult to make changes.</p><p>这块我现在还理解不到位，需要进行一些POC，之后会另外详细写一篇blog。</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[常见行业指数基金]]></title>
            <link> https://777sunny777.github.io/metaTrip/metaTrip/build/blog/funding-basic4</link>
            <guid>funding-basic4</guid>
            <pubDate>Sun, 23 Jan 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[- From 《指数基金投资指南》章节3]]></description>
            <content:encoded><![CDATA[<p>:::tip</p><ul><li>From 《指数基金投资指南》章节3</li><li>小白学习，切勿盲目跟从
:::</li></ul><h2>常见行业指数基金</h2><p>指数基金专门投资某个行业的股票，也就是行业指数基金。行业指数基金投资风险更高。
有时候宽基值指数基金没有太好机会的时候，行业指数基金对我们投资起到很好的补充作用。</p><blockquote><p>建议新手从宽基指数基金入门，积累足够经验之后在投资行业指数基金。</p></blockquote><h3>10个一级行业</h3><table><thead><tr><th>名称</th><th>包含</th><th>中证800一级行业指数2004~2017</th><th>相关指数及特点</th><th>养老产业</th></tr></thead><tbody><tr><td>材料</td><td>金属，采矿，化学制品</td><td>2.6</td><td></td><td></td></tr><tr><td>可选消费</td><td>汽车，零售， 媒体，房地产，影视业</td><td>4.7</td><td>需求比必须消费弱，有一定周期性（房地产）。中证全指可选消费指数</td><td>主要包括</td></tr><tr><td>必须消费（日常消费，主要消费）</td><td>食品，烟草，家具，饮料，酒，农副食品</td><td>9.0</td><td>稳定。上证，上证80，中证800，全指消费指数</td><td>主要包括</td></tr><tr><td>能源</td><td>能源设备与服务，石油天然气</td><td>2.0</td><td></td><td></td></tr><tr><td>金融</td><td>银行， 保险，券商</td><td>5.2</td><td>周期性，政策</td><td></td></tr><tr><td>医药</td><td>医疗保健，制药，生物科技</td><td>9.3</td><td>稳定，中证800医药，上证医药，细分医药，300/500医药指数等</td><td>主要包括</td></tr><tr><td>工业</td><td>航空航天，运输，建筑产品</td><td>3</td><td></td><td></td></tr><tr><td>信息</td><td>硬件，软件，信息技术</td><td>3.5</td><td></td><td></td></tr><tr><td>电信</td><td>固定线路，无线通信，电信业务</td><td>4.6</td><td></td><td></td></tr><tr><td>公共事业</td><td>电力，天然气，水</td><td>2.4</td><td></td><td></td></tr></tbody></table><blockquote><h4>值得投资的行业</h4><ul><li>天生更容易赚钱的行业 （消费和医药行业）</li><li>具有明显强周期的行业 （低买高卖，金融业地产，能源，部分材料行业）</li></ul></blockquote><blockquote><h4>开公司如何才能赚到钱 （茅台，可口可乐）</h4><ul><li>客户需求能够持续稳定</li><li>产品别人模仿不了，企业有护城河能保证一定利润率</li><li>再投资需求小，能够活得大量自由现金流</li><li>二级市场还要一个条件：企业愿意回馈股东，而不是乱花钱</li></ul></blockquote><blockquote><h4>其他有特定行业</h4><ul><li>地产行业，军工行约，环保行业，白酒行业</li></ul></blockquote>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[常见宽基指数基金(二)]]></title>
            <link> https://777sunny777.github.io/metaTrip/metaTrip/build/blog/funding-basic3</link>
            <guid>funding-basic3</guid>
            <pubDate>Fri, 14 Jan 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[- From 《指数基金投资指南》章节3]]></description>
            <content:encoded><![CDATA[<p>:::tip</p><ul><li>From 《指数基金投资指南》章节3</li><li>小白学习，切勿盲目跟从
:::</li></ul><h2>常见宽基指数基金</h2><table><thead><tr><th>序号</th><th>名称</th><th>指数简介</th><th>股票个数</th></tr></thead><tbody><tr><td>10</td><td>中证基本面50指数(000925, 399925)</td><td>按照4个基本面指标，挑选综合最强的50个公司</td><td>50</td></tr><tr><td>10</td><td>央视财经50指数(399550)</td><td>央视联合高校专家挑选, 忽略</td><td>50</td></tr><tr><td>10</td><td>恒生指数(HSI)</td><td>港交所, DQII 代购，香港上市规模最大50家</td><td>50</td></tr><tr><td>10</td><td>H 股指数(恒生中国企业指数)</td><td>公司在内地注册，香港上市就是H股，挑选的是40家最大的H股</td><td>40</td></tr><tr><td>10</td><td>上证50AH优选指数</td><td>27纯A，23同时具有AH公司中相对便宜的那一类</td><td>50</td></tr><tr><td>10</td><td>纳斯达克100指数(NDX)</td><td>美国股市，纳斯达克最大100家，DQII代购</td><td>100</td></tr><tr><td>10</td><td>标普500指数</td><td>类似国内的沪深300</td><td>300</td></tr></tbody></table><blockquote><h3>基本面指数特点</h3><ul><li>另一种加权策略，4个维度来衡量，营业收入，现金流，净资产和分红。</li><li>往往也都是大盘股，和上证50指数相似，单挑选股从4个维度出发，会考虑更全面些。</li></ul></blockquote><blockquote><h3>QDII 基金</h3><ul><li>投资于香港，美国等市场的基金品种</li><li>这种基金我们可以理解为‘代购’</li><li>有暂停申购，可以赎回的风险，内地市场暂时不成熟</li></ul></blockquote><blockquote><h3>H股指数特点</h3><ul><li>有重复，但不是恒生指数</li><li>以境外投资者为主</li><li>与A股指数有密切的关系，很多公司在A股和H股都有上市，比如H股指数和上证50重合度高，上证50是中国投资者为主，
H股指数是欧美投资者为主， 两者的涨跌有时差，并不严格同步，但是长期趋势一致，所以买入AH股中相对便宜的，卖出贵的是其策略</li></ul></blockquote><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>上证50指数</td><td>27纯A，23同时具有AH公司中的A股</td></tr><tr><td>50AH优选指数</td><td>27纯A，23同时具有AH公司中相对便宜的那一类</td></tr><tr><td>H股指数</td><td>17纯H，23同时具有AH公司中的H股</td></tr></tbody></table>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[常见宽基指数基金(一)]]></title>
            <link> https://777sunny777.github.io/metaTrip/metaTrip/build/blog/funding-basic2</link>
            <guid>funding-basic2</guid>
            <pubDate>Tue, 11 Jan 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[- From 《指数基金投资指南》章节3]]></description>
            <content:encoded><![CDATA[<p>:::tip</p><ul><li>From 《指数基金投资指南》章节3</li><li>小白学习，切勿盲目跟从
:::</li></ul><h2>指数基金分类</h2><p>最常见的分类就是宽基指数和行业指数。</p><ul><li>指数基金在挑选股票的时候，不限制投资行业，就是<strong>宽基指数基金</strong>。</li><li>指数基金在挑选股票的时候，限制投资行业，就是<strong>行业指数基金</strong>。行业指数基金受行业特性的影响非常大。</li></ul><p>从交易渠道上可以分为场内指数基金和场外指数基金，这个场指的是证卷交易所。</p><ul><li>场内指数基金在证卷交易所上市，可以有‘申购赎回’和‘买入卖出’两套交易体系，其中买入卖出方式需要在证卷交易所进行</li><li>场外基金，不在证卷交易所上市，只有‘申购赎回’一种</li><li>场内基金主要有两种：ETF和LOF基金，这两种基金都有可以在交易所进行自由买卖，不同的是，ETF只能通过股票交易软件交易，LOF除此之外还可以像场外基金一样通过‘申购赎回’方式交易</li></ul><h2>常见宽基指数基金</h2><table><thead><tr><th>序号</th><th>名称</th><th>指数简介</th><th>股票个数</th></tr></thead><tbody><tr><td>1</td><td>上证50指数(000016)</td><td>是从上交所挑选的沪市规模最大，流动性好，最具代表性的50只股票组成的样本</td><td>50</td></tr><tr><td>2</td><td>沪深300指数(000300, 399300)</td><td>是中证指数公司开发的，从上交所和深交所挑选的，规模最大，流动性好的300只股票</td><td>300</td></tr><tr><td>3</td><td>中证500指数(000905,399905)</td><td>是中证指数公司开发的，从上交所和深交所挑选的，排除沪深300的，国内中型公司代表</td><td>500</td></tr><tr><td>4</td><td>创业板指数(399006)</td><td>创业板最主要100家企业</td><td>100</td></tr><tr><td>5</td><td>创业板50指数(399673)</td><td>创业板最主要50家企业</td><td>50</td></tr><tr><td>6</td><td>上证红利指数(000015)</td><td>最老牌，大盘股为主，上交所过去两年平均现金股息率最高的50只股票</td><td>50</td></tr><tr><td>7</td><td>中证红利指数(000922，399922)</td><td>从上交所和深交所挑选，过去两年平均现金股息率最高的100只股票</td><td>100</td></tr><tr><td>8</td><td>深证红利指数(399324)</td><td>深交所过去两年平均现金股息率最高的40只股票</td><td>40</td></tr><tr><td>9</td><td>红利机会指数(CSPSADRP)</td><td>标普公司围绕A股开发的红利指数，挑选更严格</td><td>100</td></tr></tbody></table><blockquote><h3>指数基金的挑选</h3><ul><li>规模比较大，历史比较长，追踪效果好</li><li>要避开规模较小的指数基金，有亏本清盘风险，最好规模在1亿以上</li><li>寻找费用最低，误差最小的品种</li><li>另一种思路是选择有特色的增强型指数基金，复制指数的基础上，寻找短期机会，有风险，可能差于普通的指数基金</li></ul></blockquote><blockquote><h3>A股上交所大盘股历史走势特点</h3><ul><li>总体走势是上涨的</li><li>从03年底以来，只有07，09，15三个明显牛市，其余走平或阴跌</li><li>A股经常暴涨或暴跌，指数基金也带有这个特征，需要注意</li></ul></blockquote><blockquote><h3>上证50指数特点</h3><ul><li>大盘股为主，规模最小也有350多亿，都是关系国计民生的大公司，这些大公司股票也叫<strong>蓝筹股</strong>，上证50并不是投资市场的整体指数，更多的是<strong>投资大盘股</strong></li><li>只有上交所股票，没有深交所股票，没法反应国内股票的整体走势</li></ul></blockquote><blockquote><h3>沪深300指数特点</h3><ul><li>占国内股市全部规模的60%以上</li><li>以大盘股为主，兼顾上海和深圳上市公司</li><li>上证50包含在沪深300中，所以两个指数很多时候表现也比较重合</li></ul></blockquote><blockquote><h3>中证500指数特点</h3><ul><li>以中型上市公司为主，兼顾上海和深圳上市公司</li><li>与沪深300无重合</li></ul></blockquote><blockquote><h3>创业板指数特点</h3><ul><li>创业板相关的指数有两个，一个是创业板综指（衡量创业板所有上市公司股价平均表现），一个是创业板指数（最主要的100家创业板上市公司）</li><li>创业板50指数，相当于创业板的‘上证50’</li><li>公司规模小，以小中公司为主，更容易暴涨暴跌</li></ul></blockquote><blockquote><h3>红利指数特点</h3><ul><li>前面介绍的都是按照市值来加权的，即股票规模越大，权重越高</li><li>红利指数是按照股息率来加权的</li><li>高股息率，在熊市更有优势，熊市分到的100万能买到更多牛市分到100万的股票份额</li><li>能长期发放现金股息的公司，盈利能力财务状况更好</li></ul></blockquote>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[How to use Storybook 2]]></title>
            <link> https://777sunny777.github.io/metaTrip/metaTrip/build/blog/storybook-usage2</link>
            <guid>storybook-usage2</guid>
            <pubDate>Sun, 09 Jan 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[- 这篇blog是storybook的入门教程并且包含了我使用storybook 3年多的一些体验]]></description>
            <content:encoded><![CDATA[<p>:::tip</p><ul><li>这篇blog是storybook的入门教程并且包含了我使用storybook 3年多的一些体验 </li><li>只针对React项目</li><li>进一步学习，请访问<a href="https://storybook.js.org/">Storybook官网</a>
:::</li></ul><p><a href="https://storybook.js.org/">Storybook</a> is an open source tool for building UI components and pages in isolation. It streamlines UI development, testing, and documentation.</p><p>从Storybook的官方描述来看，他是用于快速构建UI demo的工具，可以帮用户快速构建页面；并且有很好的语法功能，轻松书写demo；还有很好的辅助插件，
比如demo的文档辅助，参数辅助，还有accessibility辅助测试等等。这一切几乎促使它成为了项目demo的最好选择。因为我的项目涉及到组件库的开发，
所以storybook就更显得合适和重要。</p><p>:::note</p><ul><li>version: v6.4.9(Currently) and <a href="https://github.com/storybookjs/storybook/releases">Latest</a>
:::</li></ul><p>Storybook 代码库更新很活跃，几乎一年一次major版本的更新，总会带来些新的功能，这篇blog我们那目前最新版本v6.4.9 为例进行说明</p><h2>4. Configure</h2><p>Storybook is configured via a folder called .storybook, which contains various configuration files.</p><p>Storybook配置文件一般是放在.storybook的文件夹下面，通过-c也可以进行路径配置。主要包含如下三个文件：main.js preview.js and manager.js
<a href="https://storybook.js.org/docs/react/configure/overview">Detials</a></p><h3>4-1. main.js</h3><p>The main configuration file is main.js.</p><p>:::note</p><ul><li>This file controls the Storybook server&#x27;s behavior, so you must restart Storybook’s process when you change it.
:::</li></ul><p>The main.js configuration file is a preset and, as such, has a powerful interface, but the key fields within it are:</p><ul><li>stories: 主要是配置storie cases的路径，默认是文件名中带有 stories 的文件，文件路径，文件名规则，文件后缀都是可配置的。</li><li>addons - 配置一下页面中需要用到的addons.</li><li>webpackFinal - 自定义的 webpack configuration.</li><li>babel - 自定义的 babel configuration.</li></ul><pre><code class="language-jsx">// .storybook/main.js

module.exports = {
  stories: [&#x27;../packages/MyStories&#x27;],
  addons: [&#x27;@storybook/addon-essentials&#x27;],
  webpackFinal: async (config, { configType }) =&gt; {
    config.module.rules.push({
      test: /\.scss$/,
      use: [&#x27;style-loader&#x27;, &#x27;css-loader&#x27;, &#x27;sass-loader&#x27;],
      include: path.resolve(__dirname, &#x27;../&#x27;),
    });

    return config;
  },
    babel: async (options) =&gt; ({
    ...options,
    // any extra options you want to set
  })
};

</code></pre><h4>On-demand story loading：</h4><p>按需加载stories，进行性能提升，<strong>Starting with Storybook 6.4</strong>, you can optimize your story loading by enabling the storyStoreV7 feature flag in your configuration as follows:</p><pre><code class="language-jsx">// .storybook/main.js

module.exports = {
  stories: [],
  addons: [&#x27;@storybook/addon-essentials&#x27;],
  features: {
    storyStoreV7: true,
  },
};

</code></pre><h3>4-2. preview.js</h3><p>To control the way stories are rendered and add global decorators and parameters</p><ul><li>This is loaded in the Canvas tab</li><li>Use preview.js for global code that applies to all stories.</li></ul><p>The preview.js file can be an ES module and export the following keys:</p><ul><li>decorators：包含页面结构和全局样式，都可以在decorators中定义</li><li>parameters：一般可以配置全局的docs和action，background</li><li>globalTypes: </li></ul><pre><code class="language-jsx">// .storybook/preview.js

// createGlobalStyle from styled-component
import GlobalStyles from &#x27;./GlobalStyles&#x27;;

export const decorators = [
  (Story) =&gt; (
    &lt;GlobalStyles /&gt;
    &lt;div style={{ margin: &#x27;3em&#x27; }}&gt;
      &lt;Story /&gt;
    &lt;/div&gt;
  ),
];

export const parameters = {
  backgrounds: {
    values: [
      { name: &#x27;red&#x27;, value: &#x27;#f00&#x27; },
      { name: &#x27;green&#x27;, value: &#x27;#0f0&#x27; },
    ],
  },
};

export const globalTypes = {
  theme: {
    name: &#x27;Theme&#x27;,
    description: &#x27;Global theme for components&#x27;,
    defaultValue: &#x27;light&#x27;,
    toolbar: {
      icon: &#x27;circlehollow&#x27;,
      // Array of plain string values or MenuItem shape (see below)
      items: [&#x27;light&#x27;, &#x27;dark&#x27;],
      // Property that specifies if the name of the item will be displayed
      showName: true,
    },
  },
};

</code></pre><h3>4-3. manager.js</h3><p>To control the layout of Storybook’s UI you can use addons.setConfig in your .storybook/manager.js:</p><pre><code class="language-jsx">// .storybook/manager.js

import { addons } from &#x27;@storybook/addons&#x27;;

addons.setConfig({
  isFullscreen: false,
  showNav: true,
  showPanel: true,
  panelPosition: &#x27;bottom&#x27;,
  enableShortcuts: true,
  isToolshown: true,
  theme: undefined,
  selectedPanel: undefined,
  initialActive: &#x27;sidebar&#x27;,
  sidebar: {
    showRoots: false,
    collapsedRoots: [&#x27;other&#x27;],
  },
  toolbar: {
    title: { hidden: false, },
    zoom: { hidden: false, },
    eject: { hidden: false, },
    copy: { hidden: false, },
    fullscreen: { hidden: false, },
  },
});

</code></pre><h2>5. Essential addons and Addons</h2><p>Storybook在发展的过程中，会吸收一些常用的addon，作为框架预制的addon，这个就是Essential addons and Addons的区别。
低版本的control 实际上是一个@storybook/addon-knobs，在V6版本可以内置生成了。但是这个插件本身目前是向下兼容的</p><h3>5-1. Essential addons</h3><p>If you&#x27;re upgrading from a previous Storybook version, you&#x27;ll need to run the following command in your terminal:</p><pre><code class="language-jsx">#With npm
npm install -D @storybook/addon-essentials

#With yarn
yarn add -D @storybook/addon-essentials

// .storybook/main.js

module.exports = {
  addons: [&#x27;@storybook/addon-essentials&#x27;],
};

</code></pre><p>There are many third-party addons as well as “official” addons developed by the Storybook core team.、
<a href="https://storybook.js.org/docs/react/essentials/introduction">Detials</a></p><ul><li>Docs</li><li>Controls</li><li>Actions</li><li>Viewport</li><li>Backgrounds</li><li>Toolbars &amp; globals</li><li>Measure</li><li>Outline</li></ul><h3>5-2. Install 3rd party addons</h3><p>Storybook has <a href="https://storybook.js.org/addons">hundreds of reusable addons</a> that are packaged as NPM modules.</p><h4>Using addons</h4><p><a href="https://storybook.js.org/docs/react/addons/install-addons#using-addons">Detials</a></p><pre><code class="language-jsx">
yarn add -D @storybook/addon-a11y

// .storybook/main.js

module.exports = {
  stories: [],
  addons: [
    // Other Storybook addons
    &#x27;@storybook/addon-a11y&#x27;, //👈 The addon registered here
  ],
};

</code></pre><img src="https://storybook.js.org/5c457fbc275d0c3e2a37aae388a6019f/storybook-addon-installed-registered.png" alt="Storybook addon" style="width:100%"/><h3>5-3. 自定义addons</h3><p>Now let’s add a panel to Storybook. Inside the src directory, create a new file called register.js and add the following:
<a href="https://storybook.js.org/docs/react/addons/writing-addons#add-a-panel">Detials</a></p><pre><code class="language-jsx">// /my-addon/src/register.js

import React from &#x27;react&#x27;;

import { addons, types } from &#x27;@storybook/addons&#x27;;

import { AddonPanel } from &#x27;@storybook/components&#x27;;

const ADDON_ID = &#x27;myaddon&#x27;;
const PANEL_ID = `${ADDON_ID}/panel`;

// give a unique name for the panel
const MyPanel = () =&gt; &lt;div&gt;MyAddon&lt;/div&gt;;

addons.register(ADDON_ID, (api) =&gt; {
  addons.add(PANEL_ID, {
    type: types.PANEL,
    title: &#x27;My Addon&#x27;,
    render: ({ active, key }) =&gt; (
      &lt;AddonPanel active={active} key={key}&gt;
        &lt;MyPanel /&gt;
      &lt;/AddonPanel&gt;
    ),
  });
});
</code></pre><p>:::note</p><ul><li>register 需要在main.js进行注册（When you register a Storybook addon, it will look for either register.js or preset.js as the entry points.）
:::</li></ul><img src="https://storybook.js.org/8a84ad965e96ef91ab0feb62f03b48b9/addon-initial-state.png" alt="Storybook addon" style="width:100%"/><h2>6. CLI options</h2><p>Storybook comes with two CLI utilities: start-storybook and build-storybook.
<a href="https://storybook.js.org/docs/react/api/cli-options">Detials</a></p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[资产与指数]]></title>
            <link> https://777sunny777.github.io/metaTrip/metaTrip/build/blog/funding-basic1</link>
            <guid>funding-basic1</guid>
            <pubDate>Thu, 06 Jan 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[- From 《指数基金投资指南》章节1，2]]></description>
            <content:encoded><![CDATA[<p>:::tip</p><ul><li>From 《指数基金投资指南》章节1，2</li><li>小白学习，切勿盲目跟从
:::</li></ul><h2>资产</h2><ul><li>能够为我们”生钱“的就是资产，<strong>现金</strong>不是资产</li><li>资产分为能够产生现金流的资产和不能产生现金流的资产</li></ul><blockquote><p>比如银行理财一个5%，一个3%，另一个是农村合作社的5%， 这些都是可以产生现金流的资产，他的价格取决于现金流的大小和稳定性。
银行的稳定性高于农村合作社，5%高于3%，你就很容易知道哪个资产更优质</p></blockquote><blockquote><p>不能产生现金流的资产，他的价格主要取决于供求关系，比如乱世黄金，特殊时期下供需关系发生改变，才会更值钱。</p></blockquote><blockquote><p>能产生现金流的资产通常比不能产生现金流的资产，<strong>长期收益率更高</strong>。黄金的长期收益率甚至低于国债。</p></blockquote><h2>指数</h2><ul><li>指数是一个选股规则，他的目的是按照某个规则挑选出一篮子股票，并反应这一篮子股票的<strong>平均价格走势</strong>。</li></ul><blockquote><p>例如沪深300指数，是由上海和深圳证券市场中选取300只A股作为样本编制而成的成分股指数，我们只需要看下沪深300指数，
就可以知道国内最大的300只股票，今天是整体涨了还是跌了。</p></blockquote><ul><li><p>指数点数，是指数背后公司的平均股价，这个点数下跌或上涨，代表指数背后公司股价的下跌或上涨，长期来看，指数点数是<strong>不断上涨的</strong></p></li><li><p>指数基金就是基金公司开发一个基金产品。也是完全按照指数的规则去选股，因为指数基金持有的股票种类，数量，比例都和指数非常接近，
所以指数基金的表现也和指数也非常接近，也就是说指数基金把指数的抽象概念变成了实际的产品。</p></li></ul><blockquote><p>指数基金的三个特点：长生不老，产期上涨，成本低。</p></blockquote>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[How to use Storybook 1]]></title>
            <link> https://777sunny777.github.io/metaTrip/metaTrip/build/blog/storybook-usage1</link>
            <guid>storybook-usage1</guid>
            <pubDate>Sat, 01 Jan 2022 00:00:00 GMT</pubDate>
            <description><![CDATA[- 这篇blog是storybook的入门教程并且包含了我使用storybook 3年多的一些体验]]></description>
            <content:encoded><![CDATA[<p>:::tip</p><ul><li>这篇blog是storybook的入门教程并且包含了我使用storybook 3年多的一些体验 </li><li>只针对React项目</li><li>进一步学习，请访问<a href="https://storybook.js.org/">Storybook官网</a>
:::</li></ul><p><a href="https://storybook.js.org/">Storybook</a> is an open source tool for building UI components and pages in isolation. It streamlines UI development, testing, and documentation.</p><p>从Storybook的官方描述来看，他是用于快速构建UI demo的工具，可以帮用户快速构建页面；并且有很好的语法功能，轻松书写demo；还有很好的辅助插件，
比如demo的文档辅助，参数辅助，还有accessibility辅助测试等等。这一切几乎促使它成为了项目demo的最好选择。因为我的项目涉及到组件库的开发，
所以storybook就更显得合适和重要。</p><p>:::note</p><ul><li>version: v6.4.9(Currently) and <a href="https://github.com/storybookjs/storybook/releases">Latest</a>
:::</li></ul><p>Storybook 代码库更新很活跃，几乎一年一次major版本的更新，总会带来些新的功能，这篇blog我们那目前最新版本v6.4.9 为例进行说明</p><h2>0. Storybook页面布局</h2><h3>Sidebar and Canvas</h3><video controls="" autoplay="" loop="" style="width:100%"><source src="https://storybook.js.org/f818682edbbcdf2c04093f633aa36761/example-browse-all-stories-optimized.mp4" type="video/mp4"/></video><h3>Shortcuts</h3><video controls="" autoplay="" loop="" style="width:100%"><source src="https://storybook.js.org/b398f68ed8889feed0a52f077510efcf/storybook-keyboard-shortcuts-optimized.mp4" type="video/mp4"/></video><h3>Toolbar</h3><video controls="" autoplay="" loop="" style="width:100%"><source src="https://storybook.js.org/8b083907d74e7f2b9a298e5f324cc751/toolbar-walkthrough-optimized.mp4" type="video/mp4"/></video><h3>Docs</h3><video controls="" autoplay="" loop="" style="width:100%"><source src="https://storybook.js.org/07234fedf00ba418879c443de0764c1c/toolbar-docs-tab-optimized.mp4" type="video/mp4"/></video><h3>Addons</h3><video controls="" autoplay="" loop="" style="width:100%"><source src="https://storybook.js.org/946b2f4bdb006e8475d21202d68b9eec/addons-walkthrough-optimized.mp4" type="video/mp4"/></video><h2>1. 安装</h2><p>Storybook 的<a href="https://storybook.js.org/docs/react/get-started/install">安装</a>很智能，npx sb init 就可以直接进行安装，但是要注意的是安装之前你必须已经有项目框架的依赖。</p><p>:::note</p><ul><li>Storybook will look into your project&#x27;s dependencies during its install process and provide you with the best configuration available.</li><li>Storybook只是需要项目框架依赖，比如react就相当于一个标识，你不需要写任何框架代码在项目中
:::</li></ul><h2>2. Write stories</h2><p>Story就是一个demo case，stories file就是存放一类demo cases的集合，这些cases根据title分成不同的类型</p><pre><code class="language-jsx">// 这个一个展示button的stories file
// Button.stories.js|jsx

import React from &#x27;react&#x27;;

import { Button } from &#x27;./Button&#x27;;

export default {
  
  // title是这个集合的名称，同时也用于storybook 导航栏的结构
  // 比如可以有层级关系，&#x27;Button/Responsive&#x27;

  title: &#x27;Button&#x27;,
  
  // component 属性可以不写, 后面解释文档的时候再详细说
  // Storybook uses the component key in the story file’s default export to extract the component&#x27;s description and props.
  
  component: Button,
};

// 这里通过export导出就生成了一个demo case page
// 路径就是左侧导航栏中 Button下面的Primary

export const Primary = () =&gt; &lt;Button primary&gt;Button&lt;/Button&gt;;

// 这里可以改变case的命名，默认是function name
Primary.storyName = &#x27;I am the primary&#x27;;

export const Secondary = () =&gt; &lt;Button backgroundColor=&quot;#ff0&quot; label=&quot;😄👍😍💯&quot; /&gt;;
export const Tertiary = () =&gt; &lt;Button backgroundColor=&quot;#ff0&quot; label=&quot;📚📕📈🤓&quot; /&gt;;

</code></pre><h3>2-1 Using args</h3><p>使用args是最新版本中storybook 比较建议的写法，主要的优点是减少重复代码，用法上也比较有章可循，便于管理。
不过根据我的经验还是要看你用storybook的target是什么，如果只是for show UI demo，使用args 的方式是可行的。
但是比如做组件库，show UI demo只是一个方面，show demo code for users 也是很重要的一点，我们希望通过storybook的cases可以让用户
直观的明白demo 要怎么写，甚至只需要他copy/paste就可以。在这种情况下，我们就需要尽量少的使用storybook提供的一些接口方法，减少storybook
对你的demo case code 的干扰。</p><p>任何时候，我们都要明白用户关心的是什么？而不是盲目的求新求变。</p><pre><code class="language-jsx">import React from &#x27;react&#x27;;
import { Button } from &#x27;./Button&#x27;;

export default {
  title: &#x27;Button&#x27;,
  component: Button,
};

//👇 We create a “template” of how args map to rendering
const Template = (args) =&gt; &lt;Button {...args} /&gt;;

// 👇 Each story then reuses that template
export const Primary = Template.bind({});
Primary.args = { background: &#x27;#ff0&#x27;, label: &#x27;Button&#x27; };

export const Secondary = Template.bind({});
Secondary.args = { ...Primary.args, label: &#x27;😄👍😍💯&#x27; };

export const Tertiary = Template.bind({});
Tertiary.args = { ...Primary.args, label: &#x27;📚📕📈🤓&#x27; };
</code></pre><h3>2-2 Remix two stories</h3><p>Story是可以相互引用的，主要也是为了减少重复代码，保持一致性。</p><pre><code class="language-jsx">import React from &#x27;react&#x27;;
import { Button } from &#x27;./Button&#x27;;
import * as TextInputStories from &#x27;./TextInput.stories&#x27;;

export default {
  title: &#x27;Button&#x27;,
  component: Button,
};

export const TestRemix = () =&gt; &lt;&gt;
  &lt;TextInputStories.Default /&gt;
  &lt;Button primary&gt;Button&lt;/Button&gt;
&lt;&gt;

</code></pre><h3>2-3 Controls</h3><p>首先Control是很好的功能，对于show UI demo 是很方便直观的展示，对于V6版本，Control 是内置插件，只需要通过Template和args配合就可以自动生成</p><p><a href="https://storybook.js.org/docs/react/essentials/controls">详细写法</a></p><p>在低版本中(V6仍然支持addons写法)，是通过安装addon-knobs插件来实现的。 </p><video controls="" autoplay="" loop="" style="width:100%"><source src="https://storybook.js.org/9d2e1f29cfb010e3aae6cd76547c4bab/addon-controls-optimized.mp4" type="video/mp4"/></video><p>根据我的经验，和using args 一样，使用还是不使用需要根据项目需求，或者寻找折中的方法而两者兼顾。</p><h3>2-4 Action</h3><p>我目前还没有找到Action的合适场景。它和Control一样的，在V6版本中是内置插件，需要argTypes来定义，新版本V6中需要写成template形式才能触发。</p><video controls="" autoplay="" loop="" style="width:100%"><source src="https://storybook.js.org/b0366940cf7195b6d5b646c6105c217c/addon-actions-optimized.mp4" type="video/mp4"/></video><pre><code class="language-jsx">import { Button } from &#x27;./Button&#x27;;

export default {
  title: &#x27;Button&#x27;,
  component: Button,
  argTypes: { onClick: { action: &#x27;clicked&#x27; } },
};

</code></pre><pre><code class="language-jsx">// .storybook/preview.js

export const parameters = {
  actions: { argTypesRegex: &#x27;^on.*&#x27; }
}

</code></pre><h3>2-5 Using parameters</h3><p>Parameters are Storybook’s method of defining static metadata for stories.
A story’s parameters can be used to provide configuration to various addons at the level of a story or group of stories.</p><p>Parameters主要是为stories做一些页面配置, 也可以在preview中进行global的配置</p><pre><code class="language-jsx">  parameters: {
    docs: { page: null },
    actions: { argTypesRegex: &#x27;^on.*&#x27; },
    centered: { disable: true },
    backgrounds: {
      values: [
        { name: &#x27;red&#x27;, value: &#x27;#f00&#x27; },
        { name: &#x27;green&#x27;, value: &#x27;#0f0&#x27; },
        { name: &#x27;blue&#x27;, value: &#x27;#00f&#x27; },
      ],
    },
  },
</code></pre><h3>2-6 Using decorators</h3><p>Decorators are a mechanism to wrap a component in arbitrary markup when rendering a story.
Components are often created with assumptions about ‘where’ they render.
Your styles might expect a theme or layout wrapper, or your UI might expect specific context or data providers.</p><p>decorators就是页面装饰，可以有机会给页面做一些dom结构或者样式的调整</p><pre><code class="language-jsx">import React from &#x27;react&#x27;;
import { Button } from &#x27;./Button&#x27;;

export default {
  title: &#x27;Button&#x27;,
  component: Button,
  decorators: [
    (Story) =&gt; (
      &lt;div style={{ margin: &#x27;3em&#x27; }}&gt;
        &lt;Story /&gt;
      &lt;/div&gt;
    ),
  ],
};
</code></pre><h2>3. Write Docs</h2><p>Storybook 目前主要提供了三种方式用于文档的书写</p><h3>3-1 利用component parameters</h3><h4>优点：</h4><ul><li>可以自动解析组件中的props</li></ul><h4>缺点：</h4><ul><li>interface的format要严格</li><li>docs中不能自定义，是自动生成的</li></ul><pre><code class="language-jsx">// ButtonGroup.stories.js|jsx
import React from &#x27;react&#x27;;
import { Button, ButtonGroup } from &#x27;./ButtonGroup&#x27;;

export default {
  title: &#x27;ButtonGroup&#x27;,
  // storybook use the component/subcomponents to extract the component&#x27;s description and props
  // override the docs.page parameters with null to remove its content
  component: ButtonGroup,
  subcomponents: { Button },
};
</code></pre><h3>3-2 mdx</h3><p>:::note</p><ul><li>Currently there&#x27;s an issue when using MDX stories with IE11. This issue does not apply to Docs page
:::</li></ul><p>MDX 是非常好的书写docs的方式，如果你的项目不需要兼容IE11，我强烈建议你用mdx的方式来写case的文档。</p><h4>优点：</h4><ul><li>可以将md和JSX混合书写，非常灵活</li></ul><h4>缺点：</h4><ul><li>不支持IE11</li></ul><p><a href="https://storybook.js.org/docs/react/writing-docs/mdx">详细</a></p><p>MDX is a standard file format that combines Markdown with JSX.
It means you can use Markdown’s terse syntax (such as # heading) for your documentation,
write stories that compile to our component story format, and freely embed JSX component blocks at any point in the file. All at once.</p><h3>3-3 利用docs parameters</h3><p>因为IE11而用不了mdx，可以尝试用jsx组件配置到docs.page的方式进行docs的书写。个人认为，如果你的项目支持IE11，而且你还希望自定义docs内容，
用这种方式是最好选择</p><h4>优点：</h4><ul><li>可以写JSX，自定义docs页面布局样式</li><li>支持IE11</li></ul><h4>缺点：</h4><ul><li>不能用md</li></ul><pre><code class="language-jsx">// ButtonGroup.stories.js|jsx
import React from &#x27;react&#x27;;
import { Button, ButtonGroup } from &#x27;./ButtonGroup&#x27;;
import { customDocumentComponemt } from &#x27;./customDocumentComponemt&#x27;; //jsx file

export default {
  title: &#x27;ButtonGroup&#x27;,
  component: ButtonGroup,
  parameters: {
    docs: {
      page: customDocumentComponemt
    }
  }
};
</code></pre>]]></content:encoded>
        </item>
    </channel>
</rss>