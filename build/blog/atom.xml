<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id> https://777sunny777.github.io/metaTrip/metaTrip/build/blog</id>
    <title>MetaTrip Blog</title>
    <updated>2022-03-09T00:00:00.000Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href=" https://777sunny777.github.io/metaTrip/metaTrip/build/blog"/>
    <subtitle>MetaTrip Blog</subtitle>
    <icon> https://777sunny777.github.io/metaTrip/metaTrip/build/img/metaIcon.png</icon>
    <entry>
        <title type="html"><![CDATA[如何挑选适合投资的指数基金]]></title>
        <id>funding-basic5</id>
        <link href=" https://777sunny777.github.io/metaTrip/metaTrip/build/blog/funding-basic5"/>
        <updated>2022-03-09T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[- From 《指数基金投资指南》章节4]]></summary>
        <content type="html"><![CDATA[<p>:::tip</p><ul><li>From 《指数基金投资指南》章节4</li><li>小白学习，切勿盲目跟从
:::</li></ul><h2>1.格雷厄姆价值投资的3大理论</h2><p>格雷厄姆是巴菲特的老师，有两部著作《证券分析 Security Analysis》 和 《聪明的投资者》。
其价值投资核心在于“低估值价值投资+指数基金”。</p><h3>1-1.价格与价值的关系</h3><p>股票有其内在价值，股票的价格围绕其内在价值上下波动。
不过虽然股价在短期内会暴涨暴跌，但长期表现还是会与股票的内在价值趋于一致。</p><h3>1-2.能力圈</h3><p>我们对所投资的品种非常了解，能判断出它大概的内在价值是多少。
我们对品种了解的越多, 内力圈也就越大，前提是我们真的了解。</p><p>巴菲特的解释是：你的能力圈，最重要的不是圈的大小，而是你知道自己的能力圈的边界所在。</p><p>后面的估值测算，解决了一部分能力圈的问题。</p><h3>1-3.安全边际</h3><p>我们要用0.4元买价值1元的东西，这个就是安全边界的核心。
我们要用比价值更低的价格去买股票。当价格大幅低于股票的内在价值的时候，这时投资才具备安全边界。</p><h2>2.估值</h2><p>我们如何知道基金的价格是不是低于价值？这就需要一些估值方法来帮助我们进行判断。</p><h3>2-1.常见的估值指标</h3><p>:::note
市盈率：公司市值/公司盈利</p><ul><li>静态市盈率：公司盈利取用公司上一年度的净利润</li><li>滚动市盈率：取用最近4个季度财报的净利润</li><li>动态市盈率：取用预估的公司下一季度净利润</li></ul><p>市盈率反应了我们愿意为获取1元的净利润付出多少代价</p><p>市值代表了我们买下这个公司理论上需要多少资金量</p><p>这个指标适用于流通性好，盈利稳定的品种。
:::</p><p>:::note
盈利收益率：市盈率的倒数， 盈利收益率高，股息率就高。市盈率就低
:::</p><p>:::note
市净率：每股股价与每股净资产的比率，公司市值/公司净资产</p><p>净资产就是资产减去负债
:::</p><p>:::note
股息率：过去一年公司的现金分红/公司的市值，随着股价波动，股价越低，股息率越高</p><p>分红率（派息率）：过去一年公司的现金分红/公司的总净利润，一般是公司预先设置好，多年不变
:::</p><h3>2-2.查询指数估计的方式</h3><p>公众号：定投十年赚十倍</p><p>指数官网查询：中证指数官网可查</p><p>还有就是收费的金融终端，一般不太需要</p><h2>3.挑选指数基金的两大策略</h2><h3>3-1. 盈利收益率法</h3><ul><li>当盈利收益率大于10%时，开始定投</li><li>当盈利收益率小于10%时，停止定投，坚定持有</li><li>当盈利收益率小于6.4%时，分批卖出指数基金，换成其他品种，分批卖出风险更低</li></ul><p>一般情况下，盈利收益率变化不大，收益大概在（15% -- 20%）</p><p>局限性：只适用于盈利稳定的价值指数，上证红利，中证红利，上证50，基本面50，上证50AH优选，央视50。</p><h3>3-2. 博格公式法</h3><p>公式计算比较绕，只说结论：</p><ul><li>在股息率高的时候买入</li><li>在市盈率处于历史较低位置时买入</li><li>买入后耐心等待“均值回归”，即市盈率从低到高。</li></ul>]]></content>
        <author>
            <name>Sheldon Y Sun</name>
            <uri>https://github.com/777sunny777</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[useEffect，you really know it?]]></title>
        <id>react1</id>
        <link href=" https://777sunny777.github.io/metaTrip/metaTrip/build/blog/react1"/>
        <updated>2022-03-08T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[- 这篇blog是对useEffect及相关hooks的深入学习。]]></summary>
        <content type="html"><![CDATA[<p>:::tip</p><ul><li>这篇blog是对useEffect及相关hooks的深入学习。
:::</li></ul><p><a href="https://reactjs.org/docs/hooks-effect.html">Using the Effect Hook</a> 对于常用的react hooks我一直认为是比较了解的，然而最近的一次项目组sharing，
讨论到这块，居然发现这么常用的hook自己的理解竟然是有偏差的，还需要去深入的学习一下。这篇blog由此而来。</p><h2>1. useEffect</h2><p>:::note
If you’re familiar with React class lifecycle methods, you can think of useEffect Hook as componentDidMount, componentDidUpdate, and componentWillUnmount combined.</p><p>我们常规的理解，useEffect应该就是之前class component生命周期中componentDidMount, componentDidUpdate, and componentWillUnmount的结合
:::</p><p>react组件中有两种常见的side effects，一种需要clearup, 一种不需要，具体如下。</p><h3>1-1. Effects Without Cleanup</h3><p>在一些情况下，我们需要运行额外的代码在react更新dom结构之后，比如ajax 请求，手动更改dom结构，后者logging的时候。
这些情况是不需要cleanup的。</p><p>我们看下面的例子：</p><pre><code class="language-jsx">class Example extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      count: 0
    };
  }

  componentDidMount() {
    document.title = `You clicked ${this.state.count} times`;
  }
  componentDidUpdate() {
    document.title = `You clicked ${this.state.count} times`;
  }

  render() {
    return (
      &lt;div&gt;
        &lt;p&gt;You clicked {this.state.count} times&lt;/p&gt;
        &lt;button onClick={() =&gt; this.setState({ count: this.state.count + 1 })}&gt;
          Click me
        &lt;/button&gt;
      &lt;/div&gt;
    );
  }
}
</code></pre><p>用class component来写的时候，我们需要用到两个生命周期函数， componentDidMount在初始render的时候触发，componentDidUpdate在每次update的时候触发
无论如何优化代码， <strong>we have to duplicate the code between these two lifecycle methods in class</strong>，我想这也是我们后面用hooks来代替的原因之一。</p><p>如果我们用Hooks来写呢</p><pre><code class="language-jsx" metastring="live">function Example() {
  const [count, setCount] = useState(0);

  useEffect(() =&gt; {
    console.log(&#x27;demo1 useEffect running&#x27;);
    document.title = `You clicked ${count} times`;
  });

  return (
    &lt;div&gt;
      &lt;p&gt;You clicked {count} times&lt;/p&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;
        Click me
      &lt;/button&gt;
    &lt;/div&gt;
  );
}
</code></pre><p>默认情况下，useEffect会在第一次render以及后面每次update的时候触发，我们不需要考虑mounting还是updateing。
it will remember the effect we used, and then run our effect after updating the DOM. This happens for every render, including the first one.</p><h3>1-2. Effects With Cleanup</h3><p>一般比较常见的需要cleanup的例子，有建立取消定时器，防止内存溢出等等，我们看react 官网class component with cleanup的例子：</p><pre><code class="language-jsx">class FriendStatus extends React.Component {
  constructor(props) {
    super(props);
    this.state = { isOnline: null };
    this.handleStatusChange = this.handleStatusChange.bind(this);
  }

  componentDidMount() {
    ChatAPI.subscribeToFriendStatus(
      this.props.friend.id,
      this.handleStatusChange
    );
  }
  componentWillUnmount() {
    ChatAPI.unsubscribeFromFriendStatus(
      this.props.friend.id,
      this.handleStatusChange
    );
  }
  handleStatusChange(status) {
    this.setState({
      isOnline: status.isOnline
    });
  }

  render() {
    if (this.state.isOnline === null) {
      return &#x27;Loading...&#x27;;
    }
    return this.state.isOnline ? &#x27;Online&#x27; : &#x27;Offline&#x27;;
  }
}
</code></pre><p>其中componentDidMount 和 componentWillUnmount 是互为镜像的。
如果我们用Hooks来写呢，需要return一个function，react会在cleanup的时候调用</p><pre><code class="language-jsx" metastring="live">function FriendStatus(props) {
  const [isOnline, setIsOnline] = useState(null);

  useEffect(() =&gt; {
    function handleStatusChange(status) {
      setIsOnline(status.isOnline);
    }
    
    console.log(&#x27;demo2 useEffect running&#x27;);
    // comment since we have no ChatAPI here, just for demo
    // ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);

    // Specify how to clean up after this effect:
    // We don’t have to return a named function from the effect. 
    // We called it cleanup here to clarify its purpose, but you could return an arrow function or call it something different.
    return function cleanup() {
      console.log(&#x27;demo2 cleanup running&#x27;);
      // ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);
    };
  });

  return (
      &lt;&gt;
        &lt;p&gt; {isOnline ? &#x27;Online&#x27; : &#x27;Offline&#x27;} &lt;/p&gt;
        &lt;button onClick={ ()=&gt;setIsOnline(&#x27;online&#x27;) } &gt;Online&lt;/button&gt;
        &lt;button onClick={ ()=&gt;setIsOnline(null) }&gt;Offline&lt;/button&gt;
      &lt;/&gt;
  )
}
</code></pre><p>:::tip
试想，如果此时你尝试着去点击online和offline的button，那么此时的return会不会被调用？</p><p>按照文档return应该是在cleanup的时候调用的，那么state变化了，会触发cleanup么？
:::</p><p>我就是在这个地方出现理解的错误，我认为state变化是不会触发cleanup的，只有在dom结构删除了的时候，也就是ummount的时候才会触发一次。
但是测试结果和我想得完全不同，每次state变化，都会先触发cleanup，然后在触发side effect。</p><p>大家可以在上面的live demo中尝试，console里有记录可查。</p><p>然后我查找文档，发现了这么两段话。</p><p>:::tip
Why did we return a function from our effect?</p><p>This is the optional cleanup mechanism for effects. Every effect may return a function that cleans up after it.
This lets us keep the logic for adding and removing subscriptions close to each other. They’re part of the same effect!
:::</p><p>:::tip
When exactly does React clean up an effect?</p><p>React performs the cleanup when the component unmounts. However, as we learned earlier, effects run for every render and not just once.
This is why React also cleans up effects from the previous render before running the effects next time. （这就是为什么React还会在下次运行效果之前清除上一次渲染的效果）
We’ll discuss why this helps avoid bugs and how to opt out of this behavior in case it creates performance issues later below.
:::</p><p>第一段话关键在于告诉我们return是每个effect中都存在的机制，<strong>不管你使用不使用，他都是effect的一部分</strong>。</p><p>第二句话关键在于告诉我们<strong>因为effect是多次运行的，所以return里的cleanup也是多次运行的</strong>，这样做是有原因的：1.避免bugs. 2.可以有退出机制。</p><h2>2. Tips for Using Effects</h2><h3>2-1. Tip: Use Multiple Effects to Separate Concerns</h3><p>Hooks let us split the code based on what it is doing rather than a lifecycle method name.
不同的逻辑分在不同的useEffect里面，是得逻辑结构更清晰，这个应该是选择hooks的原因之二。</p><pre><code class="language-jsx">function FriendStatusWithCounter(props) {
  const [count, setCount] = useState(0);
  useEffect(() =&gt; {
    document.title = `You clicked ${count} times`;
  });

  const [isOnline, setIsOnline] = useState(null);
  useEffect(() =&gt; {
    function handleStatusChange(status) {
      setIsOnline(status.isOnline);
    }

    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);
    return () =&gt; {
      ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);
    };
  });
  // ...
}
</code></pre><p>:::tip
Explanation: Why Effects Run on Each Update?</p><p>If you’re used to classes, you might be wondering why the effect cleanup phase happens after every re-render,
and not just once during unmounting. Let’s look at a practical example to see why this design helps us create components with fewer bugs.</p><p>之前的误解原因使用class component的后遗症，effect的机制是cleanup每次都会触发，react这样设计的原因是为了减少bugs</p><p>This behavior ensures consistency by default and prevents bugs that are common in class components due to <strong>missing update logic</strong>.
:::</p><p>官方的例子是关于好友在线状态的，在props更新的情况下，好友A可能被好友B替代，但是如下的例子就会显示好友B在线，但是B可能不在线。</p><pre><code class="language-jsx">  componentDidMount() {
    ChatAPI.subscribeToFriendStatus(
      this.props.friend.id,
      this.handleStatusChange
    );
  }

  componentWillUnmount() {
    ChatAPI.unsubscribeFromFriendStatus(
      this.props.friend.id,
      this.handleStatusChange
    );
  }
</code></pre><p>我们可以通过compoentDidUpdate进行解决，判断props变化了之后，关掉前一个好友A的链接，重新建立新好友B的链接，而现实中我们可能经常忘了添加这个逻辑。
所以用useEffect，每次都会cleanup前一次的记录，然后重新开始effect update。</p><pre><code class="language-jsx">  componentDidMount() {
    ChatAPI.subscribeToFriendStatus(
      this.props.friend.id,
      this.handleStatusChange
    );
  }

  componentDidUpdate(prevProps) {
    // Unsubscribe from the previous friend.id
    ChatAPI.unsubscribeFromFriendStatus(
      prevProps.friend.id,
      this.handleStatusChange
    );
    // Subscribe to the next friend.id
    ChatAPI.subscribeToFriendStatus(
      this.props.friend.id,
      this.handleStatusChange
    );
  }

  componentWillUnmount() {
    ChatAPI.unsubscribeFromFriendStatus(
      this.props.friend.id,
      this.handleStatusChange
    );
  }

</code></pre><h3>2-2. Tip: Optimizing Performance by Skipping Effects</h3><p>In some cases, cleaning up or applying the effect after every render might create a performance problem.
In class components, we can solve this by writing an extra comparison with prevProps or prevState inside componentDidUpdate</p><pre><code class="language-jsx">componentDidUpdate(prevProps, prevState) {
  if (prevState.count !== this.state.count) {
    document.title = `You clicked ${this.state.count} times`;
  }
}
</code></pre><p>在hooks中如何处理呢：</p><pre><code class="language-jsx" metastring="live">function Example() {
  const [count, setCount] = useState(0);
  const [count2, setCount2] = useState(100);

  useEffect(() =&gt; {
    console.log(&#x27;demo3 useEffect running&#x27;);
    document.title = `You clicked ${count} times`;
    
    return () =&gt; {
      console.log(&#x27;demo3 cleanup running&#x27;);
    };
  }, [count]);

  return (
    &lt;div&gt;
      &lt;p&gt;You clicked {count} times, click {count2} times&lt;/p&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;
        Click me +
      &lt;/button&gt;
      &lt;button onClick={() =&gt; setCount2(count2 - 1)}&gt;
        Click me -
      &lt;/button&gt;
    &lt;/div&gt;
  );
}
</code></pre><p>这个例子告诉我们，useEffect只接受count 变化的case，对count2变化是不处理的。当然cleanup也是会处理每次count的更新。而不是接受所有的props更新。
<strong>也就是通过选择监控的props，过滤掉多余render的触发。</strong></p><h3>2-3. Others</h3><p>:::tip
If you use this optimization, make sure the array includes all values from the component scope (such as props and state)
that change over time and that are used by the effect. </p><p>Otherwise, your code will reference stale values from previous renders.
:::</p><p>:::tip
If you want to run an effect and clean it up only once (on mount and unmount), you can pass an empty array ([]) as a second argument.
This tells React that your effect doesn’t depend on any values from props or state, so it never needs to re-run.</p><p>If you pass an empty array ([]), the props and state inside the effect will always have their initial values.
While passing [] as the second argument is closer to the familiar componentDidMount and componentWillUnmount mental model,</p><p>Also, don’t forget that React defers running useEffect until after the browser has painted, so doing extra work is less of a problem.
:::</p><h2>3. useLayoutEffect</h2><p>The signature is identical to useEffect, but it fires synchronously after all DOM mutations.
Use this to read layout from the DOM and synchronously re-render. Updates scheduled inside useLayoutEffect will be flushed synchronously,
before the browser has a chance to paint.</p><p>我目前的理解，useEffect是异步的，在浏览器渲染完成之后进行。而useLayoutEffect是同步的，在浏览器渲染前更新，是block浏览器渲染进程的。</p><p>useLayoutEffect 无论代码先后都是在useEffect前执行的。</p><pre><code class="language-jsx" metastring="live">function Example() {
  const [count, setCount] = useState(0);

  useEffect(() =&gt; {
    console.log(&#x27;demo4 useEffect after render&#x27;);
    document.title = `You clicked ${count} times`;
    
    return ()=&gt;{
        console.log(&#x27;demo4 cleanup running&#x27;);
    }
  });

  useLayoutEffect(() =&gt; {
    console.log(&#x27;demo4 useLayoutEffect running&#x27;);

    return ()=&gt;{
        console.log(&#x27;demo4 useLayoutEffect cleanup running&#x27;);
    }
  });

  console.log(&#x27;demo4 update DOM&#x27;);

  return (
    &lt;div&gt;
      &lt;p&gt;You clicked {count} times&lt;/p&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;
        Click me
      &lt;/button&gt;
    &lt;/div&gt;
  );
}
</code></pre><p>:::tip
useEffect 是异步非阻塞调用</p><p>useLayoutEffect 是同步阻塞调用</p><p>useEffect 浏览器绘制后</p><p>useLayoutEffect 在 DOM 变更（React 的更新）后，浏览器绘制前完成所有操作
:::</p><p>0，7，之后暂停1秒，出现5，说明layoutEffect阻塞了useEffect。</p><pre><code class="language-jsx" metastring="live">function FuncCom () {
    const [counter, setCounter] = useState(0);

    useEffect(() =&gt; {
        if (counter === 2) {
            setCounter(5)
        }
    });

    useLayoutEffect(() =&gt; {
        if (counter === 7) {
            setTimeout(()=&gt;{
                setCounter(2)
            }, 1000);
        }
    });

    return (
        &lt;div style={{fontSize: &#x27;40px&#x27;}}&gt;
            &lt;button onClick={() =&gt; setCounter(7)}&gt;{counter}&lt;/button&gt;
        &lt;/div&gt;
    )
}
</code></pre>]]></content>
        <author>
            <name>Sheldon Y Sun</name>
            <uri>https://github.com/777sunny777</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Micro FrontEnd Basic]]></title>
        <id>microFE1</id>
        <link href=" https://777sunny777.github.io/metaTrip/metaTrip/build/blog/microFE1"/>
        <updated>2022-01-26T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[- 这是我对于MFE比较系统学习记录的首篇blog]]></summary>
        <content type="html"><![CDATA[<p>:::tip</p><ul><li>这是我对于MFE比较系统学习记录的首篇blog </li><li>主要参考的Cam Jackson的文章<a href="https://martinfowler.com/articles/micro-frontends.html">Micro Frontends</a>
:::</li></ul><p>Cam Jackson 是Thoughtworks的全栈工程师，这篇文章虽然出自2019年，但是对于MFE概念的初学者还是友好的，可以比较容易的理解。
相应的文章最后还提供了MEF的example, 按照文章顺序去学习，应该可以很快入门。我的这篇blog，算是对他的文章和我一点经验的总结，
我们直接步入正题。</p><h2>1. Micro Frontends</h2><p>&quot;An architectural style where independently deliverable frontend applications are composed into a greater whole&quot;</p><p>这是Cam Jackson 或者说是Thoughtworks对MFE的定义。我们从中可以提取到两个重点：</p><ul><li>independently deliverable. 独立交付</li><li>composed into a greater whole. 组合构成整体</li></ul><h3>1-1. MFE cost</h3><p>因为后面我们要详细解读下MFE的Benefits，所以这里主要是先将一下他的cost：</p><p>:::note
there are no free lunches when it comes to software architecture - everything comes with a cost.</p><ul><li>Some micro frontend implementations can lead to duplication of dependencies</li><li>increasing the number of bytes our users must download</li><li>the dramatic increase in team autonomy can cause fragmentation in the way your teams work</li></ul><p>Nonetheless, we believe that these risks can be managed, and that the benefits of micro frontends often outweigh the costs
:::</p><p>总体来说，MFE可能会导致依赖重复，增加了需要download的asset，还有就是独立团队工作方式上的一些挑战。对于结论Thoughtworks认为总体上MFE还是利大于弊的。
我们接下来说说Benefits。</p><h2>2. Benefits</h2><h3>2-1. Incremental upgrades(增量升级)</h3><p>The endgame here is that we&#x27;re afforded more freedom to make case-by-case decisions on individual parts of our product,
and to make incremental upgrades to our architecture, our dependencies, and our user experience.
If there is a major breaking change in our main framework, each micro frontend can be upgraded whenever it makes sense,
rather than being forced to stop the world and upgrade everything at once. If we want to experiment with new technology,
or new modes of interaction, we can do it in a more isolated fashion than we could before.</p><p>好处之一就是MFE的子模块升级是自主的，并且与主模块解耦，即主模块有过有些大的major breaking changes，子模块也不需要和主模块同步进行修改和升级。
而是可以选择一个自身合适的时机来进行升级。</p><p>:::tip
这里面我的理解是：主模块的以来还是会default影响MFE的子模块的，但是子模块自身可以选择要不要这种影响，即依赖主模块的依赖，
或者关闭主模块依赖而只选择自身的依赖，这样就比较灵活和自主了。这条我会在后面进行相应的印证。
:::</p><h3>2-2. Simple, decoupled codebases(简单，解耦)</h3><p>These smaller codebases tend to be simpler and easier for developers to work with.
In particular, we avoid the complexity arising from unintentional and inappropriate coupling between components
that should not know about each other. </p><p>micro frontends push you to be explicit and deliberate about how data and events flow
between different parts of the application, which is something that we should have been doing anyway!</p><p>MFE一定是小而精的，尽量减少组件间数据或事件传输，这一点需要我们深入的思考。</p><h3>2-3. Independent deployment(独立部署)</h3><p>Just as with microservices, independent deployability of micro frontends is key.
This reduces the scope of any given deployment, which in turn reduces the associated risk.
Regardless of how or where your frontend code is hosted, each micro frontend should have
its own continuous delivery pipeline, which builds, tests and deploys it all the way to production.
We should be able to deploy each micro frontend with very little thought given to the current state of
other codebases or pipelines. It shouldn&#x27;t matter if the old monolith is on a fixed, manual,
quarterly release cycle, or if the team next door has pushed a half-finished or broken feature into their master branch.
If a given micro frontend is ready to go to production, it should be able to do so, and that decision
should be up to the team who build and maintain it.</p><p>MFE是需要对立进行build，test和deploy到production的，这个也是其主要特征之一，也是一般项目进行MFE架构重构的主要目的。</p><img src="/metaTrip/build/img/blog/deployment.png" alt="" style="width:100%"/><h3>2-4. Autonomous teams(自治团队)</h3><p>Teams can have full ownership of everything they need to deliver value to customers,
which enables them to move quickly and effectively</p><p>依赖越少，响应越灵活。这个和第三条比较相辅相成。</p><img src="/metaTrip/build/img/blog/horizontal.png" alt="" style="width:100%"/><h2>3. Integration approaches</h2><p>:::note
there is a micro frontend for each page in the application, and there is a single container application, which:</p><ul><li>renders common page elements such as headers and footers</li><li>addresses cross-cutting concerns like authentication and navigation</li><li>brings the various micro frontends together onto the page, and tells each micro frontend when and where to render itself
:::</li></ul><img src="/metaTrip/build/img/blog/composition.png" alt="" style="width:100%"/><h3>3-1. Server-side template composition</h3><p>rendering HTML on the server out of multiple templates or fragments.
We have an index.html which contains any common page elements,
and then uses server-side includes to plug in page-specific content from fragment HTML files</p><pre><code class="language-jsx">&lt;html lang=&quot;en&quot; dir=&quot;ltr&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;Feed me&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;🍽 Feed me&lt;/h1&gt;
    &lt;!--# include file=&quot;$PAGE.html&quot; --&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre><pre><code class="language-jsx">server {
    listen 8080;
    server_name localhost;

    root /usr/share/nginx/html;
    index index.html;
    ssi on;

    # Redirect / to /browse
    rewrite ^/$ http://localhost:8080/browse redirect;

    # Decide which HTML fragment to insert based on the URL
    location /browse {
      set $PAGE &#x27;browse&#x27;;
    }
    location /order {
      set $PAGE &#x27;order&#x27;;
    }
    location /profile {
      set $PAGE &#x27;profile&#x27;
    }

    # All locations should render through index.html
    error_page 404 /index.html;
}
</code></pre><p>This example shows how micro frontends is not necessarily a new technique,
and does not have to be complicated.
As long as we&#x27;re careful about how our design decisions affect the autonomy of our codebases and our teams, we can achieve many of the same benefits regardless of our tech stack.</p><p>实际上这个例子只是要告诉我们，MFE是一种思想，并不是一个新的技术，或者需要新的技术才可以实现。
只要满足独立交付，组合构成整体都应该是MFE的范畴。</p><h3>3-2. Build-time integration</h3><p>One approach that we sometimes see is to publish each micro frontend as a package,
and have the container application include them all as library dependencies.
Here is how the container&#x27;s package.json might look for our example app:</p><pre><code class="language-jsx">{
  &quot;name&quot;: &quot;@feed-me/container&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;description&quot;: &quot;A food delivery web app&quot;,
  &quot;dependencies&quot;: {
    &quot;@feed-me/browse-restaurants&quot;: &quot;^1.2.3&quot;,
    &quot;@feed-me/order-food&quot;: &quot;^4.5.6&quot;,
    &quot;@feed-me/user-profile&quot;: &quot;^7.8.9&quot;
  }
}
</code></pre><p>component ui library 框架就是一种build-time的模式。他的引用是基于package的，依赖的形式存在。
很多大的项目也是这种假的MFE开发方式。</p><p>At first this seems to make sense. It produces a single deployable Javascript bundle,
as is usual, allowing us to de-duplicate common dependencies from our various applications.
However, this approach means that we have to re-compile and release every single micro frontend
in order to release a change to any individual part of the product. Just as with microservices,
we&#x27;ve seen enough pain caused by such a lockstep release process that we would recommend
strongly against this kind of approach to micro frontends.</p><p>这种方式的不合理之处就在于compile和release都需要同步进行，这个和MFE独立交付的概念是绝对相反的，是反MFE的一种方式。
We should find a way to integrate our micro frontends at run-time, rather than at build-time.</p><h3>3-3. Run-time integration via iframes</h3><p>One of the simplest approaches to composing applications together in the browser is the humble iframe.
By their nature, iframes make it easy to build a page out of independent sub-pages.
They also offer a good degree of isolation in terms of styling and global variables not interfering with each other.</p><pre><code class="language-jsx">&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Feed me!&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Welcome to Feed me!&lt;/h1&gt;

    &lt;iframe id=&quot;micro-frontend-container&quot;&gt;&lt;/iframe&gt;

    &lt;script type=&quot;text/javascript&quot;&gt;
      const microFrontendsByRoute = {
        &#x27;/&#x27;: &#x27;https://browse.example.com/index.html&#x27;,
        &#x27;/order-food&#x27;: &#x27;https://order.example.com/index.html&#x27;,
        &#x27;/user-profile&#x27;: &#x27;https://profile.example.com/index.html&#x27;,
      };

      const iframe = document.getElementById(&#x27;micro-frontend-container&#x27;);
      iframe.src = microFrontendsByRoute[window.location.pathname];
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre><p>It can be difficult to build integrations between different parts of the application,
so they make routing, history, and deep-linking more complicated,
and they present some extra challenges to making your page fully responsive.</p><p>iframes觉得是MFE最简单的实现方式，我们主要考虑到灵活性的一些问题而不去采用它。比如responsive的实现就很困难。</p><h3>3-4. Run-time integration via JavaScript(主要实现方式)</h3><p>probably the most flexible one, and the one that we see teams adopting most frequently.
Each micro frontend is included onto the page using a <strong>script</strong> tag, and upon load exposes a global function as its entry-point.
The container application then determines which micro frontend should be mounted,
and calls the relevant function to tell a micro frontend when and where to render itself.</p><pre><code class="language-jsx">&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Feed me!&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Welcome to Feed me!&lt;/h1&gt;

    &lt;!-- These scripts don&#x27;t render anything immediately --&gt;
    &lt;!-- Instead they attach entry-point functions to `window` --&gt;
    &lt;script src=&quot;https://browse.example.com/bundle.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;https://order.example.com/bundle.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;https://profile.example.com/bundle.js&quot;&gt;&lt;/script&gt;

    &lt;div id=&quot;micro-frontend-root&quot;&gt;&lt;/div&gt;

    &lt;script type=&quot;text/javascript&quot;&gt;
      // These global functions are attached to window by the above scripts
      const microFrontendsByRoute = {
        &#x27;/&#x27;: window.renderBrowseRestaurants,
        &#x27;/order-food&#x27;: window.renderOrderFood,
        &#x27;/user-profile&#x27;: window.renderUserProfile,
      };
      const renderFunction = microFrontendsByRoute[window.location.pathname];

      // Having determined the entry-point function, we now call it,
      // giving it the ID of the element where it should render itself
      renderFunction(&#x27;micro-frontend-root&#x27;);
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre><p>The above is obviously a primitive example, but it demonstrates the basic technique.
Unlike with build-time integration, we can deploy each of the bundle.js files independently.
And unlike with iframes, we have full flexibility to build integrations between our micro frontends however we like.
We could extend the above code in many ways, for example to only download each JavaScript bundle as needed,
or to pass data in and out when rendering a micro frontend.The flexibility of this approach, combined with the independent
deployability, makes it our default choice, and the one that we&#x27;ve seen in the wild most often.</p><p>这种方式与iframe相比，可以解决子模块间的同步协作问题，比如responsive。与build-time相比，可以独立交付。而且还可以按需加载。
所以成为了MFE实现的最主要方式。</p><h3>3-5. Run-time integration via Web Components</h3><p> for each micro frontend to define an HTML custom element for the container to instantiate,
instead of defining a global function for the container to call.</p><pre><code class="language-jsx">&lt;html&gt;
 &lt;head&gt;
   &lt;title&gt;Feed me!&lt;/title&gt;
 &lt;/head&gt;
 &lt;body&gt;
   &lt;h1&gt;Welcome to Feed me!&lt;/h1&gt;

   &lt;!-- These scripts don&#x27;t render anything immediately --&gt;
   &lt;!-- Instead they each define a custom element type --&gt;
   &lt;script src=&quot;https://browse.example.com/bundle.js&quot;&gt;&lt;/script&gt;
   &lt;script src=&quot;https://order.example.com/bundle.js&quot;&gt;&lt;/script&gt;
   &lt;script src=&quot;https://profile.example.com/bundle.js&quot;&gt;&lt;/script&gt;

   &lt;div id=&quot;micro-frontend-root&quot;&gt;&lt;/div&gt;

   &lt;script type=&quot;text/javascript&quot;&gt;
     // These element types are defined by the above scripts
     const webComponentsByRoute = {
       &#x27;/&#x27;: &#x27;micro-frontend-browse-restaurants&#x27;,
       &#x27;/order-food&#x27;: &#x27;micro-frontend-order-food&#x27;,
       &#x27;/user-profile&#x27;: &#x27;micro-frontend-user-profile&#x27;,
     };
     const webComponentType = webComponentsByRoute[window.location.pathname];

     // Having determined the right web component custom element type,
     // we now create an instance of it and attach it to the document
     const root = document.getElementById(&#x27;micro-frontend-root&#x27;);
     const webComponent = document.createElement(webComponentType);
     root.appendChild(webComponent);
   &lt;/script&gt;
 &lt;/body&gt;
&lt;/html&gt;
</code></pre><p>the main difference being that you are opting in to doing things &#x27;the web component way&#x27;.
If you like the web component spec, and you like the idea of using capabilities that the browser provides,
then this is a good option. If you prefer to define your own interface between the container
application and micro frontends, then you might prefer the previous example instead.</p><p>如果不需要考虑IE浏览器，也是一个很好的选择。</p><h2>4. Styling</h2><p>In a micro frontends landscape, many of these problems are exacerbated. For example,
if one team&#x27;s micro frontend has a stylesheet that says h2 { color: black; },
and another one says h2 { color: blue; }, and both these selectors are attached to the same page,
then someone is going to be disappointed! This is not a new problem,
but it&#x27;s made worse by the fact that these selectors were written by different teams at different times,
and the code is probably split across separate repositories, making it more difficult to discover.</p><p>:::tip
MFE主要是解决css的样式重名问题，目前的css有多种写法来避免这个问题， BEM，sass/less, css in js.
我目前对这个具体的解决方式还有待理解，后面我会去印证一下。
:::</p><h2>5. Shared component libraries</h2><p>We mentioned above that visual consistency across micro frontends is important,
and one approach to this is to develop a library of shared, re-usable UI components.
In general we believe that this a good idea, although it is difficult to do well.
The main benefits of creating such a library are reduced effort through re-use of code,
and visual consistency. In addition, your component library can serve as a living styleguide,
and it can be a great point of collaboration between developers and designers.</p><p>简单来说，MFE也是需要同意视觉UI 标准的，这趋势就需要一个component ui 库来支持。比如mui，bootstrap。
或者是项目自建，自建的方式可以是从多个子模块中抽取common的组件。而不用day1的时候就构建。
但是这个component ui 库是需要的。 </p><p>:::tip
我需要在项目中进一步印证一下。比如BRP和New UI MFE的关系
:::</p><h2>6. Cross-application communication</h2><p>One of the most common questions regarding micro frontends is <strong>how to let them talk to each other</strong>.
In general, we recommend having them communicate as little as possible,
as it often reintroduces the sort of inappropriate coupling that we&#x27;re seeking to avoid in the first place.</p><p>That said, some level of cross-app communication is often needed. </p><ul><li>Custom events allow micro frontends to communicate indirectly, which is a good way to minimise direct coupling,
though it does make it harder to determine and enforce the contract that exists between micro frontends. </li><li>Alternatively, the React model of passing callbacks and data downwards (in this case downwards from the container
application to the micro frontends) is also a good solution that makes the contract more explicit. </li><li>A third alternative is to use the address bar as a communication mechanism.</li></ul><p>Whatever approach we choose, we want our micro frontends to communicate by sending messages or events to each other,
and avoid having any shared state. </p><p>Just like sharing a database across microservices, as soon as we share our data structures and domain models,
we create massive amounts of coupling, and it becomes extremely difficult to make changes.</p><p>这块我现在还理解不到位，需要进行一些POC，之后会另外详细写一篇blog。</p>]]></content>
        <author>
            <name>Sheldon Y Sun</name>
            <uri>https://github.com/777sunny777</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[常见行业指数基金]]></title>
        <id>funding-basic4</id>
        <link href=" https://777sunny777.github.io/metaTrip/metaTrip/build/blog/funding-basic4"/>
        <updated>2022-01-23T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[- From 《指数基金投资指南》章节3]]></summary>
        <content type="html"><![CDATA[<p>:::tip</p><ul><li>From 《指数基金投资指南》章节3</li><li>小白学习，切勿盲目跟从
:::</li></ul><h2>常见行业指数基金</h2><p>指数基金专门投资某个行业的股票，也就是行业指数基金。行业指数基金投资风险更高。
有时候宽基值指数基金没有太好机会的时候，行业指数基金对我们投资起到很好的补充作用。</p><blockquote><p>建议新手从宽基指数基金入门，积累足够经验之后在投资行业指数基金。</p></blockquote><h3>10个一级行业</h3><table><thead><tr><th>名称</th><th>包含</th><th>中证800一级行业指数2004~2017</th><th>相关指数及特点</th><th>养老产业</th></tr></thead><tbody><tr><td>材料</td><td>金属，采矿，化学制品</td><td>2.6</td><td></td><td></td></tr><tr><td>可选消费</td><td>汽车，零售， 媒体，房地产，影视业</td><td>4.7</td><td>需求比必须消费弱，有一定周期性（房地产）。中证全指可选消费指数</td><td>主要包括</td></tr><tr><td>必须消费（日常消费，主要消费）</td><td>食品，烟草，家具，饮料，酒，农副食品</td><td>9.0</td><td>稳定。上证，上证80，中证800，全指消费指数</td><td>主要包括</td></tr><tr><td>能源</td><td>能源设备与服务，石油天然气</td><td>2.0</td><td></td><td></td></tr><tr><td>金融</td><td>银行， 保险，券商</td><td>5.2</td><td>周期性，政策</td><td></td></tr><tr><td>医药</td><td>医疗保健，制药，生物科技</td><td>9.3</td><td>稳定，中证800医药，上证医药，细分医药，300/500医药指数等</td><td>主要包括</td></tr><tr><td>工业</td><td>航空航天，运输，建筑产品</td><td>3</td><td></td><td></td></tr><tr><td>信息</td><td>硬件，软件，信息技术</td><td>3.5</td><td></td><td></td></tr><tr><td>电信</td><td>固定线路，无线通信，电信业务</td><td>4.6</td><td></td><td></td></tr><tr><td>公共事业</td><td>电力，天然气，水</td><td>2.4</td><td></td><td></td></tr></tbody></table><blockquote><h4>值得投资的行业</h4><ul><li>天生更容易赚钱的行业 （消费和医药行业）</li><li>具有明显强周期的行业 （低买高卖，金融业地产，能源，部分材料行业）</li></ul></blockquote><blockquote><h4>开公司如何才能赚到钱 （茅台，可口可乐）</h4><ul><li>客户需求能够持续稳定</li><li>产品别人模仿不了，企业有护城河能保证一定利润率</li><li>再投资需求小，能够活得大量自由现金流</li><li>二级市场还要一个条件：企业愿意回馈股东，而不是乱花钱</li></ul></blockquote><blockquote><h4>其他有特定行业</h4><ul><li>地产行业，军工行约，环保行业，白酒行业</li></ul></blockquote>]]></content>
        <author>
            <name>Sheldon Y Sun</name>
            <uri>https://github.com/777sunny777</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[常见宽基指数基金(二)]]></title>
        <id>funding-basic3</id>
        <link href=" https://777sunny777.github.io/metaTrip/metaTrip/build/blog/funding-basic3"/>
        <updated>2022-01-14T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[- From 《指数基金投资指南》章节3]]></summary>
        <content type="html"><![CDATA[<p>:::tip</p><ul><li>From 《指数基金投资指南》章节3</li><li>小白学习，切勿盲目跟从
:::</li></ul><h2>常见宽基指数基金</h2><table><thead><tr><th>序号</th><th>名称</th><th>指数简介</th><th>股票个数</th></tr></thead><tbody><tr><td>10</td><td>中证基本面50指数(000925, 399925)</td><td>按照4个基本面指标，挑选综合最强的50个公司</td><td>50</td></tr><tr><td>10</td><td>央视财经50指数(399550)</td><td>央视联合高校专家挑选, 忽略</td><td>50</td></tr><tr><td>10</td><td>恒生指数(HSI)</td><td>港交所, DQII 代购，香港上市规模最大50家</td><td>50</td></tr><tr><td>10</td><td>H 股指数(恒生中国企业指数)</td><td>公司在内地注册，香港上市就是H股，挑选的是40家最大的H股</td><td>40</td></tr><tr><td>10</td><td>上证50AH优选指数</td><td>27纯A，23同时具有AH公司中相对便宜的那一类</td><td>50</td></tr><tr><td>10</td><td>纳斯达克100指数(NDX)</td><td>美国股市，纳斯达克最大100家，DQII代购</td><td>100</td></tr><tr><td>10</td><td>标普500指数</td><td>类似国内的沪深300</td><td>300</td></tr></tbody></table><blockquote><h3>基本面指数特点</h3><ul><li>另一种加权策略，4个维度来衡量，营业收入，现金流，净资产和分红。</li><li>往往也都是大盘股，和上证50指数相似，单挑选股从4个维度出发，会考虑更全面些。</li></ul></blockquote><blockquote><h3>QDII 基金</h3><ul><li>投资于香港，美国等市场的基金品种</li><li>这种基金我们可以理解为‘代购’</li><li>有暂停申购，可以赎回的风险，内地市场暂时不成熟</li></ul></blockquote><blockquote><h3>H股指数特点</h3><ul><li>有重复，但不是恒生指数</li><li>以境外投资者为主</li><li>与A股指数有密切的关系，很多公司在A股和H股都有上市，比如H股指数和上证50重合度高，上证50是中国投资者为主，
H股指数是欧美投资者为主， 两者的涨跌有时差，并不严格同步，但是长期趋势一致，所以买入AH股中相对便宜的，卖出贵的是其策略</li></ul></blockquote><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>上证50指数</td><td>27纯A，23同时具有AH公司中的A股</td></tr><tr><td>50AH优选指数</td><td>27纯A，23同时具有AH公司中相对便宜的那一类</td></tr><tr><td>H股指数</td><td>17纯H，23同时具有AH公司中的H股</td></tr></tbody></table>]]></content>
        <author>
            <name>Sheldon Y Sun</name>
            <uri>https://github.com/777sunny777</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[常见宽基指数基金(一)]]></title>
        <id>funding-basic2</id>
        <link href=" https://777sunny777.github.io/metaTrip/metaTrip/build/blog/funding-basic2"/>
        <updated>2022-01-11T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[- From 《指数基金投资指南》章节3]]></summary>
        <content type="html"><![CDATA[<p>:::tip</p><ul><li>From 《指数基金投资指南》章节3</li><li>小白学习，切勿盲目跟从
:::</li></ul><h2>指数基金分类</h2><p>最常见的分类就是宽基指数和行业指数。</p><ul><li>指数基金在挑选股票的时候，不限制投资行业，就是<strong>宽基指数基金</strong>。</li><li>指数基金在挑选股票的时候，限制投资行业，就是<strong>行业指数基金</strong>。行业指数基金受行业特性的影响非常大。</li></ul><p>从交易渠道上可以分为场内指数基金和场外指数基金，这个场指的是证卷交易所。</p><ul><li>场内指数基金在证卷交易所上市，可以有‘申购赎回’和‘买入卖出’两套交易体系，其中买入卖出方式需要在证卷交易所进行</li><li>场外基金，不在证卷交易所上市，只有‘申购赎回’一种</li><li>场内基金主要有两种：ETF和LOF基金，这两种基金都有可以在交易所进行自由买卖，不同的是，ETF只能通过股票交易软件交易，LOF除此之外还可以像场外基金一样通过‘申购赎回’方式交易</li></ul><h2>常见宽基指数基金</h2><table><thead><tr><th>序号</th><th>名称</th><th>指数简介</th><th>股票个数</th></tr></thead><tbody><tr><td>1</td><td>上证50指数(000016)</td><td>是从上交所挑选的沪市规模最大，流动性好，最具代表性的50只股票组成的样本</td><td>50</td></tr><tr><td>2</td><td>沪深300指数(000300, 399300)</td><td>是中证指数公司开发的，从上交所和深交所挑选的，规模最大，流动性好的300只股票</td><td>300</td></tr><tr><td>3</td><td>中证500指数(000905,399905)</td><td>是中证指数公司开发的，从上交所和深交所挑选的，排除沪深300的，国内中型公司代表</td><td>500</td></tr><tr><td>4</td><td>创业板指数(399006)</td><td>创业板最主要100家企业</td><td>100</td></tr><tr><td>5</td><td>创业板50指数(399673)</td><td>创业板最主要50家企业</td><td>50</td></tr><tr><td>6</td><td>上证红利指数(000015)</td><td>最老牌，大盘股为主，上交所过去两年平均现金股息率最高的50只股票</td><td>50</td></tr><tr><td>7</td><td>中证红利指数(000922，399922)</td><td>从上交所和深交所挑选，过去两年平均现金股息率最高的100只股票</td><td>100</td></tr><tr><td>8</td><td>深证红利指数(399324)</td><td>深交所过去两年平均现金股息率最高的40只股票</td><td>40</td></tr><tr><td>9</td><td>红利机会指数(CSPSADRP)</td><td>标普公司围绕A股开发的红利指数，挑选更严格</td><td>100</td></tr></tbody></table><blockquote><h3>指数基金的挑选</h3><ul><li>规模比较大，历史比较长，追踪效果好</li><li>要避开规模较小的指数基金，有亏本清盘风险，最好规模在1亿以上</li><li>寻找费用最低，误差最小的品种</li><li>另一种思路是选择有特色的增强型指数基金，复制指数的基础上，寻找短期机会，有风险，可能差于普通的指数基金</li></ul></blockquote><blockquote><h3>A股上交所大盘股历史走势特点</h3><ul><li>总体走势是上涨的</li><li>从03年底以来，只有07，09，15三个明显牛市，其余走平或阴跌</li><li>A股经常暴涨或暴跌，指数基金也带有这个特征，需要注意</li></ul></blockquote><blockquote><h3>上证50指数特点</h3><ul><li>大盘股为主，规模最小也有350多亿，都是关系国计民生的大公司，这些大公司股票也叫<strong>蓝筹股</strong>，上证50并不是投资市场的整体指数，更多的是<strong>投资大盘股</strong></li><li>只有上交所股票，没有深交所股票，没法反应国内股票的整体走势</li></ul></blockquote><blockquote><h3>沪深300指数特点</h3><ul><li>占国内股市全部规模的60%以上</li><li>以大盘股为主，兼顾上海和深圳上市公司</li><li>上证50包含在沪深300中，所以两个指数很多时候表现也比较重合</li></ul></blockquote><blockquote><h3>中证500指数特点</h3><ul><li>以中型上市公司为主，兼顾上海和深圳上市公司</li><li>与沪深300无重合</li></ul></blockquote><blockquote><h3>创业板指数特点</h3><ul><li>创业板相关的指数有两个，一个是创业板综指（衡量创业板所有上市公司股价平均表现），一个是创业板指数（最主要的100家创业板上市公司）</li><li>创业板50指数，相当于创业板的‘上证50’</li><li>公司规模小，以小中公司为主，更容易暴涨暴跌</li></ul></blockquote><blockquote><h3>红利指数特点</h3><ul><li>前面介绍的都是按照市值来加权的，即股票规模越大，权重越高</li><li>红利指数是按照股息率来加权的</li><li>高股息率，在熊市更有优势，熊市分到的100万能买到更多牛市分到100万的股票份额</li><li>能长期发放现金股息的公司，盈利能力财务状况更好</li></ul></blockquote>]]></content>
        <author>
            <name>Sheldon Y Sun</name>
            <uri>https://github.com/777sunny777</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[How to use Storybook 2]]></title>
        <id>storybook-usage2</id>
        <link href=" https://777sunny777.github.io/metaTrip/metaTrip/build/blog/storybook-usage2"/>
        <updated>2022-01-09T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[- 这篇blog是storybook的入门教程并且包含了我使用storybook 3年多的一些体验]]></summary>
        <content type="html"><![CDATA[<p>:::tip</p><ul><li>这篇blog是storybook的入门教程并且包含了我使用storybook 3年多的一些体验 </li><li>只针对React项目</li><li>进一步学习，请访问<a href="https://storybook.js.org/">Storybook官网</a>
:::</li></ul><p><a href="https://storybook.js.org/">Storybook</a> is an open source tool for building UI components and pages in isolation. It streamlines UI development, testing, and documentation.</p><p>从Storybook的官方描述来看，他是用于快速构建UI demo的工具，可以帮用户快速构建页面；并且有很好的语法功能，轻松书写demo；还有很好的辅助插件，
比如demo的文档辅助，参数辅助，还有accessibility辅助测试等等。这一切几乎促使它成为了项目demo的最好选择。因为我的项目涉及到组件库的开发，
所以storybook就更显得合适和重要。</p><p>:::note</p><ul><li>version: v6.4.9(Currently) and <a href="https://github.com/storybookjs/storybook/releases">Latest</a>
:::</li></ul><p>Storybook 代码库更新很活跃，几乎一年一次major版本的更新，总会带来些新的功能，这篇blog我们那目前最新版本v6.4.9 为例进行说明</p><h2>4. Configure</h2><p>Storybook is configured via a folder called .storybook, which contains various configuration files.</p><p>Storybook配置文件一般是放在.storybook的文件夹下面，通过-c也可以进行路径配置。主要包含如下三个文件：main.js preview.js and manager.js
<a href="https://storybook.js.org/docs/react/configure/overview">Detials</a></p><h3>4-1. main.js</h3><p>The main configuration file is main.js.</p><p>:::note</p><ul><li>This file controls the Storybook server&#x27;s behavior, so you must restart Storybook’s process when you change it.
:::</li></ul><p>The main.js configuration file is a preset and, as such, has a powerful interface, but the key fields within it are:</p><ul><li>stories: 主要是配置storie cases的路径，默认是文件名中带有 stories 的文件，文件路径，文件名规则，文件后缀都是可配置的。</li><li>addons - 配置一下页面中需要用到的addons.</li><li>webpackFinal - 自定义的 webpack configuration.</li><li>babel - 自定义的 babel configuration.</li></ul><pre><code class="language-jsx">// .storybook/main.js

module.exports = {
  stories: [&#x27;../packages/MyStories&#x27;],
  addons: [&#x27;@storybook/addon-essentials&#x27;],
  webpackFinal: async (config, { configType }) =&gt; {
    config.module.rules.push({
      test: /\.scss$/,
      use: [&#x27;style-loader&#x27;, &#x27;css-loader&#x27;, &#x27;sass-loader&#x27;],
      include: path.resolve(__dirname, &#x27;../&#x27;),
    });

    return config;
  },
    babel: async (options) =&gt; ({
    ...options,
    // any extra options you want to set
  })
};

</code></pre><h4>On-demand story loading：</h4><p>按需加载stories，进行性能提升，<strong>Starting with Storybook 6.4</strong>, you can optimize your story loading by enabling the storyStoreV7 feature flag in your configuration as follows:</p><pre><code class="language-jsx">// .storybook/main.js

module.exports = {
  stories: [],
  addons: [&#x27;@storybook/addon-essentials&#x27;],
  features: {
    storyStoreV7: true,
  },
};

</code></pre><h3>4-2. preview.js</h3><p>To control the way stories are rendered and add global decorators and parameters</p><ul><li>This is loaded in the Canvas tab</li><li>Use preview.js for global code that applies to all stories.</li></ul><p>The preview.js file can be an ES module and export the following keys:</p><ul><li>decorators：包含页面结构和全局样式，都可以在decorators中定义</li><li>parameters：一般可以配置全局的docs和action，background</li><li>globalTypes: </li></ul><pre><code class="language-jsx">// .storybook/preview.js

// createGlobalStyle from styled-component
import GlobalStyles from &#x27;./GlobalStyles&#x27;;

export const decorators = [
  (Story) =&gt; (
    &lt;GlobalStyles /&gt;
    &lt;div style={{ margin: &#x27;3em&#x27; }}&gt;
      &lt;Story /&gt;
    &lt;/div&gt;
  ),
];

export const parameters = {
  backgrounds: {
    values: [
      { name: &#x27;red&#x27;, value: &#x27;#f00&#x27; },
      { name: &#x27;green&#x27;, value: &#x27;#0f0&#x27; },
    ],
  },
};

export const globalTypes = {
  theme: {
    name: &#x27;Theme&#x27;,
    description: &#x27;Global theme for components&#x27;,
    defaultValue: &#x27;light&#x27;,
    toolbar: {
      icon: &#x27;circlehollow&#x27;,
      // Array of plain string values or MenuItem shape (see below)
      items: [&#x27;light&#x27;, &#x27;dark&#x27;],
      // Property that specifies if the name of the item will be displayed
      showName: true,
    },
  },
};

</code></pre><h3>4-3. manager.js</h3><p>To control the layout of Storybook’s UI you can use addons.setConfig in your .storybook/manager.js:</p><pre><code class="language-jsx">// .storybook/manager.js

import { addons } from &#x27;@storybook/addons&#x27;;

addons.setConfig({
  isFullscreen: false,
  showNav: true,
  showPanel: true,
  panelPosition: &#x27;bottom&#x27;,
  enableShortcuts: true,
  isToolshown: true,
  theme: undefined,
  selectedPanel: undefined,
  initialActive: &#x27;sidebar&#x27;,
  sidebar: {
    showRoots: false,
    collapsedRoots: [&#x27;other&#x27;],
  },
  toolbar: {
    title: { hidden: false, },
    zoom: { hidden: false, },
    eject: { hidden: false, },
    copy: { hidden: false, },
    fullscreen: { hidden: false, },
  },
});

</code></pre><h2>5. Essential addons and Addons</h2><p>Storybook在发展的过程中，会吸收一些常用的addon，作为框架预制的addon，这个就是Essential addons and Addons的区别。
低版本的control 实际上是一个@storybook/addon-knobs，在V6版本可以内置生成了。但是这个插件本身目前是向下兼容的</p><h3>5-1. Essential addons</h3><p>If you&#x27;re upgrading from a previous Storybook version, you&#x27;ll need to run the following command in your terminal:</p><pre><code class="language-jsx">#With npm
npm install -D @storybook/addon-essentials

#With yarn
yarn add -D @storybook/addon-essentials

// .storybook/main.js

module.exports = {
  addons: [&#x27;@storybook/addon-essentials&#x27;],
};

</code></pre><p>There are many third-party addons as well as “official” addons developed by the Storybook core team.、
<a href="https://storybook.js.org/docs/react/essentials/introduction">Detials</a></p><ul><li>Docs</li><li>Controls</li><li>Actions</li><li>Viewport</li><li>Backgrounds</li><li>Toolbars &amp; globals</li><li>Measure</li><li>Outline</li></ul><h3>5-2. Install 3rd party addons</h3><p>Storybook has <a href="https://storybook.js.org/addons">hundreds of reusable addons</a> that are packaged as NPM modules.</p><h4>Using addons</h4><p><a href="https://storybook.js.org/docs/react/addons/install-addons#using-addons">Detials</a></p><pre><code class="language-jsx">
yarn add -D @storybook/addon-a11y

// .storybook/main.js

module.exports = {
  stories: [],
  addons: [
    // Other Storybook addons
    &#x27;@storybook/addon-a11y&#x27;, //👈 The addon registered here
  ],
};

</code></pre><img src="https://storybook.js.org/5c457fbc275d0c3e2a37aae388a6019f/storybook-addon-installed-registered.png" alt="Storybook addon" style="width:100%"/><h3>5-3. 自定义addons</h3><p>Now let’s add a panel to Storybook. Inside the src directory, create a new file called register.js and add the following:
<a href="https://storybook.js.org/docs/react/addons/writing-addons#add-a-panel">Detials</a></p><pre><code class="language-jsx">// /my-addon/src/register.js

import React from &#x27;react&#x27;;

import { addons, types } from &#x27;@storybook/addons&#x27;;

import { AddonPanel } from &#x27;@storybook/components&#x27;;

const ADDON_ID = &#x27;myaddon&#x27;;
const PANEL_ID = `${ADDON_ID}/panel`;

// give a unique name for the panel
const MyPanel = () =&gt; &lt;div&gt;MyAddon&lt;/div&gt;;

addons.register(ADDON_ID, (api) =&gt; {
  addons.add(PANEL_ID, {
    type: types.PANEL,
    title: &#x27;My Addon&#x27;,
    render: ({ active, key }) =&gt; (
      &lt;AddonPanel active={active} key={key}&gt;
        &lt;MyPanel /&gt;
      &lt;/AddonPanel&gt;
    ),
  });
});
</code></pre><p>:::note</p><ul><li>register 需要在main.js进行注册（When you register a Storybook addon, it will look for either register.js or preset.js as the entry points.）
:::</li></ul><img src="https://storybook.js.org/8a84ad965e96ef91ab0feb62f03b48b9/addon-initial-state.png" alt="Storybook addon" style="width:100%"/><h2>6. CLI options</h2><p>Storybook comes with two CLI utilities: start-storybook and build-storybook.
<a href="https://storybook.js.org/docs/react/api/cli-options">Detials</a></p>]]></content>
        <author>
            <name>Sheldon Y Sun</name>
            <uri>https://github.com/777sunny777</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[资产与指数]]></title>
        <id>funding-basic1</id>
        <link href=" https://777sunny777.github.io/metaTrip/metaTrip/build/blog/funding-basic1"/>
        <updated>2022-01-06T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[- From 《指数基金投资指南》章节1，2]]></summary>
        <content type="html"><![CDATA[<p>:::tip</p><ul><li>From 《指数基金投资指南》章节1，2</li><li>小白学习，切勿盲目跟从
:::</li></ul><h2>资产</h2><ul><li>能够为我们”生钱“的就是资产，<strong>现金</strong>不是资产</li><li>资产分为能够产生现金流的资产和不能产生现金流的资产</li></ul><blockquote><p>比如银行理财一个5%，一个3%，另一个是农村合作社的5%， 这些都是可以产生现金流的资产，他的价格取决于现金流的大小和稳定性。
银行的稳定性高于农村合作社，5%高于3%，你就很容易知道哪个资产更优质</p></blockquote><blockquote><p>不能产生现金流的资产，他的价格主要取决于供求关系，比如乱世黄金，特殊时期下供需关系发生改变，才会更值钱。</p></blockquote><blockquote><p>能产生现金流的资产通常比不能产生现金流的资产，<strong>长期收益率更高</strong>。黄金的长期收益率甚至低于国债。</p></blockquote><h2>指数</h2><ul><li>指数是一个选股规则，他的目的是按照某个规则挑选出一篮子股票，并反应这一篮子股票的<strong>平均价格走势</strong>。</li></ul><blockquote><p>例如沪深300指数，是由上海和深圳证券市场中选取300只A股作为样本编制而成的成分股指数，我们只需要看下沪深300指数，
就可以知道国内最大的300只股票，今天是整体涨了还是跌了。</p></blockquote><ul><li><p>指数点数，是指数背后公司的平均股价，这个点数下跌或上涨，代表指数背后公司股价的下跌或上涨，长期来看，指数点数是<strong>不断上涨的</strong></p></li><li><p>指数基金就是基金公司开发一个基金产品。也是完全按照指数的规则去选股，因为指数基金持有的股票种类，数量，比例都和指数非常接近，
所以指数基金的表现也和指数也非常接近，也就是说指数基金把指数的抽象概念变成了实际的产品。</p></li></ul><blockquote><p>指数基金的三个特点：长生不老，产期上涨，成本低。</p></blockquote>]]></content>
        <author>
            <name>Sheldon Y Sun</name>
            <uri>https://github.com/777sunny777</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[How to use Storybook 1]]></title>
        <id>storybook-usage1</id>
        <link href=" https://777sunny777.github.io/metaTrip/metaTrip/build/blog/storybook-usage1"/>
        <updated>2022-01-01T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[- 这篇blog是storybook的入门教程并且包含了我使用storybook 3年多的一些体验]]></summary>
        <content type="html"><![CDATA[<p>:::tip</p><ul><li>这篇blog是storybook的入门教程并且包含了我使用storybook 3年多的一些体验 </li><li>只针对React项目</li><li>进一步学习，请访问<a href="https://storybook.js.org/">Storybook官网</a>
:::</li></ul><p><a href="https://storybook.js.org/">Storybook</a> is an open source tool for building UI components and pages in isolation. It streamlines UI development, testing, and documentation.</p><p>从Storybook的官方描述来看，他是用于快速构建UI demo的工具，可以帮用户快速构建页面；并且有很好的语法功能，轻松书写demo；还有很好的辅助插件，
比如demo的文档辅助，参数辅助，还有accessibility辅助测试等等。这一切几乎促使它成为了项目demo的最好选择。因为我的项目涉及到组件库的开发，
所以storybook就更显得合适和重要。</p><p>:::note</p><ul><li>version: v6.4.9(Currently) and <a href="https://github.com/storybookjs/storybook/releases">Latest</a>
:::</li></ul><p>Storybook 代码库更新很活跃，几乎一年一次major版本的更新，总会带来些新的功能，这篇blog我们那目前最新版本v6.4.9 为例进行说明</p><h2>0. Storybook页面布局</h2><h3>Sidebar and Canvas</h3><video controls="" autoplay="" loop="" style="width:100%"><source src="https://storybook.js.org/f818682edbbcdf2c04093f633aa36761/example-browse-all-stories-optimized.mp4" type="video/mp4"/></video><h3>Shortcuts</h3><video controls="" autoplay="" loop="" style="width:100%"><source src="https://storybook.js.org/b398f68ed8889feed0a52f077510efcf/storybook-keyboard-shortcuts-optimized.mp4" type="video/mp4"/></video><h3>Toolbar</h3><video controls="" autoplay="" loop="" style="width:100%"><source src="https://storybook.js.org/8b083907d74e7f2b9a298e5f324cc751/toolbar-walkthrough-optimized.mp4" type="video/mp4"/></video><h3>Docs</h3><video controls="" autoplay="" loop="" style="width:100%"><source src="https://storybook.js.org/07234fedf00ba418879c443de0764c1c/toolbar-docs-tab-optimized.mp4" type="video/mp4"/></video><h3>Addons</h3><video controls="" autoplay="" loop="" style="width:100%"><source src="https://storybook.js.org/946b2f4bdb006e8475d21202d68b9eec/addons-walkthrough-optimized.mp4" type="video/mp4"/></video><h2>1. 安装</h2><p>Storybook 的<a href="https://storybook.js.org/docs/react/get-started/install">安装</a>很智能，npx sb init 就可以直接进行安装，但是要注意的是安装之前你必须已经有项目框架的依赖。</p><p>:::note</p><ul><li>Storybook will look into your project&#x27;s dependencies during its install process and provide you with the best configuration available.</li><li>Storybook只是需要项目框架依赖，比如react就相当于一个标识，你不需要写任何框架代码在项目中
:::</li></ul><h2>2. Write stories</h2><p>Story就是一个demo case，stories file就是存放一类demo cases的集合，这些cases根据title分成不同的类型</p><pre><code class="language-jsx">// 这个一个展示button的stories file
// Button.stories.js|jsx

import React from &#x27;react&#x27;;

import { Button } from &#x27;./Button&#x27;;

export default {
  
  // title是这个集合的名称，同时也用于storybook 导航栏的结构
  // 比如可以有层级关系，&#x27;Button/Responsive&#x27;

  title: &#x27;Button&#x27;,
  
  // component 属性可以不写, 后面解释文档的时候再详细说
  // Storybook uses the component key in the story file’s default export to extract the component&#x27;s description and props.
  
  component: Button,
};

// 这里通过export导出就生成了一个demo case page
// 路径就是左侧导航栏中 Button下面的Primary

export const Primary = () =&gt; &lt;Button primary&gt;Button&lt;/Button&gt;;

// 这里可以改变case的命名，默认是function name
Primary.storyName = &#x27;I am the primary&#x27;;

export const Secondary = () =&gt; &lt;Button backgroundColor=&quot;#ff0&quot; label=&quot;😄👍😍💯&quot; /&gt;;
export const Tertiary = () =&gt; &lt;Button backgroundColor=&quot;#ff0&quot; label=&quot;📚📕📈🤓&quot; /&gt;;

</code></pre><h3>2-1 Using args</h3><p>使用args是最新版本中storybook 比较建议的写法，主要的优点是减少重复代码，用法上也比较有章可循，便于管理。
不过根据我的经验还是要看你用storybook的target是什么，如果只是for show UI demo，使用args 的方式是可行的。
但是比如做组件库，show UI demo只是一个方面，show demo code for users 也是很重要的一点，我们希望通过storybook的cases可以让用户
直观的明白demo 要怎么写，甚至只需要他copy/paste就可以。在这种情况下，我们就需要尽量少的使用storybook提供的一些接口方法，减少storybook
对你的demo case code 的干扰。</p><p>任何时候，我们都要明白用户关心的是什么？而不是盲目的求新求变。</p><pre><code class="language-jsx">import React from &#x27;react&#x27;;
import { Button } from &#x27;./Button&#x27;;

export default {
  title: &#x27;Button&#x27;,
  component: Button,
};

//👇 We create a “template” of how args map to rendering
const Template = (args) =&gt; &lt;Button {...args} /&gt;;

// 👇 Each story then reuses that template
export const Primary = Template.bind({});
Primary.args = { background: &#x27;#ff0&#x27;, label: &#x27;Button&#x27; };

export const Secondary = Template.bind({});
Secondary.args = { ...Primary.args, label: &#x27;😄👍😍💯&#x27; };

export const Tertiary = Template.bind({});
Tertiary.args = { ...Primary.args, label: &#x27;📚📕📈🤓&#x27; };
</code></pre><h3>2-2 Remix two stories</h3><p>Story是可以相互引用的，主要也是为了减少重复代码，保持一致性。</p><pre><code class="language-jsx">import React from &#x27;react&#x27;;
import { Button } from &#x27;./Button&#x27;;
import * as TextInputStories from &#x27;./TextInput.stories&#x27;;

export default {
  title: &#x27;Button&#x27;,
  component: Button,
};

export const TestRemix = () =&gt; &lt;&gt;
  &lt;TextInputStories.Default /&gt;
  &lt;Button primary&gt;Button&lt;/Button&gt;
&lt;&gt;

</code></pre><h3>2-3 Controls</h3><p>首先Control是很好的功能，对于show UI demo 是很方便直观的展示，对于V6版本，Control 是内置插件，只需要通过Template和args配合就可以自动生成</p><p><a href="https://storybook.js.org/docs/react/essentials/controls">详细写法</a></p><p>在低版本中(V6仍然支持addons写法)，是通过安装addon-knobs插件来实现的。 </p><video controls="" autoplay="" loop="" style="width:100%"><source src="https://storybook.js.org/9d2e1f29cfb010e3aae6cd76547c4bab/addon-controls-optimized.mp4" type="video/mp4"/></video><p>根据我的经验，和using args 一样，使用还是不使用需要根据项目需求，或者寻找折中的方法而两者兼顾。</p><h3>2-4 Action</h3><p>我目前还没有找到Action的合适场景。它和Control一样的，在V6版本中是内置插件，需要argTypes来定义，新版本V6中需要写成template形式才能触发。</p><video controls="" autoplay="" loop="" style="width:100%"><source src="https://storybook.js.org/b0366940cf7195b6d5b646c6105c217c/addon-actions-optimized.mp4" type="video/mp4"/></video><pre><code class="language-jsx">import { Button } from &#x27;./Button&#x27;;

export default {
  title: &#x27;Button&#x27;,
  component: Button,
  argTypes: { onClick: { action: &#x27;clicked&#x27; } },
};

</code></pre><pre><code class="language-jsx">// .storybook/preview.js

export const parameters = {
  actions: { argTypesRegex: &#x27;^on.*&#x27; }
}

</code></pre><h3>2-5 Using parameters</h3><p>Parameters are Storybook’s method of defining static metadata for stories.
A story’s parameters can be used to provide configuration to various addons at the level of a story or group of stories.</p><p>Parameters主要是为stories做一些页面配置, 也可以在preview中进行global的配置</p><pre><code class="language-jsx">  parameters: {
    docs: { page: null },
    actions: { argTypesRegex: &#x27;^on.*&#x27; },
    centered: { disable: true },
    backgrounds: {
      values: [
        { name: &#x27;red&#x27;, value: &#x27;#f00&#x27; },
        { name: &#x27;green&#x27;, value: &#x27;#0f0&#x27; },
        { name: &#x27;blue&#x27;, value: &#x27;#00f&#x27; },
      ],
    },
  },
</code></pre><h3>2-6 Using decorators</h3><p>Decorators are a mechanism to wrap a component in arbitrary markup when rendering a story.
Components are often created with assumptions about ‘where’ they render.
Your styles might expect a theme or layout wrapper, or your UI might expect specific context or data providers.</p><p>decorators就是页面装饰，可以有机会给页面做一些dom结构或者样式的调整</p><pre><code class="language-jsx">import React from &#x27;react&#x27;;
import { Button } from &#x27;./Button&#x27;;

export default {
  title: &#x27;Button&#x27;,
  component: Button,
  decorators: [
    (Story) =&gt; (
      &lt;div style={{ margin: &#x27;3em&#x27; }}&gt;
        &lt;Story /&gt;
      &lt;/div&gt;
    ),
  ],
};
</code></pre><h2>3. Write Docs</h2><p>Storybook 目前主要提供了三种方式用于文档的书写</p><h3>3-1 利用component parameters</h3><h4>优点：</h4><ul><li>可以自动解析组件中的props</li></ul><h4>缺点：</h4><ul><li>interface的format要严格</li><li>docs中不能自定义，是自动生成的</li></ul><pre><code class="language-jsx">// ButtonGroup.stories.js|jsx
import React from &#x27;react&#x27;;
import { Button, ButtonGroup } from &#x27;./ButtonGroup&#x27;;

export default {
  title: &#x27;ButtonGroup&#x27;,
  // storybook use the component/subcomponents to extract the component&#x27;s description and props
  // override the docs.page parameters with null to remove its content
  component: ButtonGroup,
  subcomponents: { Button },
};
</code></pre><h3>3-2 mdx</h3><p>:::note</p><ul><li>Currently there&#x27;s an issue when using MDX stories with IE11. This issue does not apply to Docs page
:::</li></ul><p>MDX 是非常好的书写docs的方式，如果你的项目不需要兼容IE11，我强烈建议你用mdx的方式来写case的文档。</p><h4>优点：</h4><ul><li>可以将md和JSX混合书写，非常灵活</li></ul><h4>缺点：</h4><ul><li>不支持IE11</li></ul><p><a href="https://storybook.js.org/docs/react/writing-docs/mdx">详细</a></p><p>MDX is a standard file format that combines Markdown with JSX.
It means you can use Markdown’s terse syntax (such as # heading) for your documentation,
write stories that compile to our component story format, and freely embed JSX component blocks at any point in the file. All at once.</p><h3>3-3 利用docs parameters</h3><p>因为IE11而用不了mdx，可以尝试用jsx组件配置到docs.page的方式进行docs的书写。个人认为，如果你的项目支持IE11，而且你还希望自定义docs内容，
用这种方式是最好选择</p><h4>优点：</h4><ul><li>可以写JSX，自定义docs页面布局样式</li><li>支持IE11</li></ul><h4>缺点：</h4><ul><li>不能用md</li></ul><pre><code class="language-jsx">// ButtonGroup.stories.js|jsx
import React from &#x27;react&#x27;;
import { Button, ButtonGroup } from &#x27;./ButtonGroup&#x27;;
import { customDocumentComponemt } from &#x27;./customDocumentComponemt&#x27;; //jsx file

export default {
  title: &#x27;ButtonGroup&#x27;,
  component: ButtonGroup,
  parameters: {
    docs: {
      page: customDocumentComponemt
    }
  }
};
</code></pre>]]></content>
        <author>
            <name>Sheldon Y Sun</name>
            <uri>https://github.com/777sunny777</uri>
        </author>
    </entry>
</feed>